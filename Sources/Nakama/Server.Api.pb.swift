// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: server/server/api.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//*
// Nakama Protocol Buffers API
//
// This file describes the API used to communicate messages from Nakama Clients to the server.
//
// Author: The Nakama Authors

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// StoragePermissionRead is the core domain type representing Storage Read permission
enum Server_StoragePermissionRead: SwiftProtobuf.Enum {
  typealias RawValue = Int

  //// Storage owner does not have read access.
  case noRead // = 0

  //// Only storage owner has read access.
  case ownerRead // = 1

  //// Storage owner and every other user has read access.
  case publicRead // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .noRead
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noRead
    case 1: self = .ownerRead
    case 2: self = .publicRead
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noRead: return 0
    case .ownerRead: return 1
    case .publicRead: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///*
/// StoragePermissionWrite is the core domain type representing Storage Write permission
enum Server_StoragePermissionWrite: SwiftProtobuf.Enum {
  typealias RawValue = Int

  //// Storage owner does not have write access.
  case noWrite // = 0

  //// Storage owner has write access.
  case ownerWrite // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .noWrite
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noWrite
    case 1: self = .ownerWrite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noWrite: return 0
    case .ownerWrite: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

///*
/// Heartbeat message used as server ping to check for client liveliness.
/// This is separate to any other protocol-level ping (e.g. Websocket PING).
struct Server_Heartbeat: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Heartbeat"

  //// Server UTC timestamp in milliseconds.
  var timestamp: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// An error that has occured on the server.
/// The error could be result of bad input, or unexpected system error.
/// Check Error Code for more info.
struct Server_Error: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Error"

  //// Error code - must be one of the Error.Code enums above.
  var code: Int32 = 0

  //// Specific error message.
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  //// Predefined errors that are produced by the server.
  enum Code: SwiftProtobuf.Enum {
    typealias RawValue = Int

    //// An unexpected error that is unrecoverable.
    case runtimeException // = 0

    //// Server received a message that is not recognized.
    case unrecognizedPayload // = 1

    //// Server received an Envelop message but the internal message is unrecognised. Most likely a protocol mismatch.
    case missingPayload // = 2

    //// The message did not include the required data in the correct format.
    case badInput // = 3

    //// Authentication failure.
    case authError // = 4

    //// Login failed because ID/device/email did not exist.
    case userNotFound // = 5

    //// Registration failed because ID/device/email exists.
    case userRegisterInuse // = 6

    //// Linking operation failed because link exists.
    case userLinkInuse // = 7

    //// Linking operation failed because third-party service was unreachable.
    case userLinkProviderUnavailable // = 8

    //// Unlinking operation failed because you cannot unlink last ID.
    case userUnlinkDisallowed // = 9

    //// Handle is in-use by another user.
    case userHandleInuse // = 10

    //// Group names must be unique and it's already in use.
    case groupNameInuse // = 11

    //// Group leave operation not allowed because the user is the last admin.
    case groupLastAdmin // = 12

    //// Storage write operation failed.
    case storageRejected // = 13

    //// Match with given ID was not found in the system.
    case matchNotFound // = 14

    //// Runtime function name was not found in system registry.
    case runtimeFunctionNotFound // = 15

    //// Runtime function caused an internal server error and did not complete.
    case runtimeFunctionException // = 16
    case UNRECOGNIZED(Int)

    init() {
      self = .runtimeException
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .runtimeException
      case 1: self = .unrecognizedPayload
      case 2: self = .missingPayload
      case 3: self = .badInput
      case 4: self = .authError
      case 5: self = .userNotFound
      case 6: self = .userRegisterInuse
      case 7: self = .userLinkInuse
      case 8: self = .userLinkProviderUnavailable
      case 9: self = .userUnlinkDisallowed
      case 10: self = .userHandleInuse
      case 11: self = .groupNameInuse
      case 12: self = .groupLastAdmin
      case 13: self = .storageRejected
      case 14: self = .matchNotFound
      case 15: self = .runtimeFunctionNotFound
      case 16: self = .runtimeFunctionException
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .runtimeException: return 0
      case .unrecognizedPayload: return 1
      case .missingPayload: return 2
      case .badInput: return 3
      case .authError: return 4
      case .userNotFound: return 5
      case .userRegisterInuse: return 6
      case .userLinkInuse: return 7
      case .userLinkProviderUnavailable: return 8
      case .userUnlinkDisallowed: return 9
      case .userHandleInuse: return 10
      case .groupNameInuse: return 11
      case .groupLastAdmin: return 12
      case .storageRejected: return 13
      case .matchNotFound: return 14
      case .runtimeFunctionNotFound: return 15
      case .runtimeFunctionException: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Authentication message used to register or login a user and generate a token.
///
/// @returns AuthenticateResponse
struct Server_AuthenticateRequest: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateRequest"

  //// Optional collationID to track server response.
  var collationID: String {
    get {return _storage._collationID}
    set {_uniqueStorage()._collationID = newValue}
  }

  //// OneOf authentication methods.
  var id: OneOf_ID? {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  //// Email address and password.
  var email: Server_AuthenticateRequest.Email {
    get {
      if case .email(let v)? = _storage._id {return v}
      return Server_AuthenticateRequest.Email()
    }
    set {_uniqueStorage()._id = .email(newValue)}
  }

  //// Facebook OAuth Access Token.
  var facebook: String {
    get {
      if case .facebook(let v)? = _storage._id {return v}
      return String()
    }
    set {_uniqueStorage()._id = .facebook(newValue)}
  }

  //// Google OAuth Access Token.
  var google: String {
    get {
      if case .google(let v)? = _storage._id {return v}
      return String()
    }
    set {_uniqueStorage()._id = .google(newValue)}
  }

  //// GameCenter Authentication.
  var gameCenter: Server_AuthenticateRequest.GameCenter {
    get {
      if case .gameCenter(let v)? = _storage._id {return v}
      return Server_AuthenticateRequest.GameCenter()
    }
    set {_uniqueStorage()._id = .gameCenter(newValue)}
  }

  //// Steam Token.
  var steam: String {
    get {
      if case .steam(let v)? = _storage._id {return v}
      return String()
    }
    set {_uniqueStorage()._id = .steam(newValue)}
  }

  //// Device ID authentication.
  var device: String {
    get {
      if case .device(let v)? = _storage._id {return v}
      return String()
    }
    set {_uniqueStorage()._id = .device(newValue)}
  }

  //// Custom ID authentication.
  var custom: String {
    get {
      if case .custom(let v)? = _storage._id {return v}
      return String()
    }
    set {_uniqueStorage()._id = .custom(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  //// OneOf authentication methods.
  enum OneOf_ID: Equatable {
    //// Email address and password.
    case email(Server_AuthenticateRequest.Email)
    //// Facebook OAuth Access Token.
    case facebook(String)
    //// Google OAuth Access Token.
    case google(String)
    //// GameCenter Authentication.
    case gameCenter(Server_AuthenticateRequest.GameCenter)
    //// Steam Token.
    case steam(String)
    //// Device ID authentication.
    case device(String)
    //// Custom ID authentication.
    case custom(String)

    static func ==(lhs: Server_AuthenticateRequest.OneOf_ID, rhs: Server_AuthenticateRequest.OneOf_ID) -> Bool {
      switch (lhs, rhs) {
      case (.email(let l), .email(let r)): return l == r
      case (.facebook(let l), .facebook(let r)): return l == r
      case (.google(let l), .google(let r)): return l == r
      case (.gameCenter(let l), .gameCenter(let r)): return l == r
      case (.steam(let l), .steam(let r)): return l == r
      case (.device(let l), .device(let r)): return l == r
      case (.custom(let l), .custom(let r)): return l == r
      default: return false
      }
    }
  }

  ///*
  /// Email-based authentication.
  struct Email: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_AuthenticateRequest.protoMessageName + ".Email"

    //// Email address.
    var email: String = String()

    //// Password.
    var password: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.email)
        case 2: try decoder.decodeSingularStringField(value: &self.password)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.email.isEmpty {
        try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
      }
      if !self.password.isEmpty {
        try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  ///*
  /// GameCenter authentication.
  ///
  /// https://developer.apple.com/documentation/gamekit/gklocalplayer/1515407-generateidentityverificationsign
  struct GameCenter: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_AuthenticateRequest.protoMessageName + ".GameCenter"

    //// PlayerID generated by GameCenter.
    var playerID: String = String()

    //// BundleID generated by GameCenter.
    var bundleID: String = String()

    //// The date and time that the signature was created.
    var timestamp: Int64 = 0

    //// A random NSString used to compute the hash and keep it randomized.
    var salt: String = String()

    //// The verification signature data generated.
    var signature: String = String()

    //// The URL for the public encryption key.
    var publicKeyURL: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.playerID)
        case 2: try decoder.decodeSingularStringField(value: &self.bundleID)
        case 3: try decoder.decodeSingularInt64Field(value: &self.timestamp)
        case 4: try decoder.decodeSingularStringField(value: &self.salt)
        case 5: try decoder.decodeSingularStringField(value: &self.signature)
        case 6: try decoder.decodeSingularStringField(value: &self.publicKeyURL)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.playerID.isEmpty {
        try visitor.visitSingularStringField(value: self.playerID, fieldNumber: 1)
      }
      if !self.bundleID.isEmpty {
        try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 2)
      }
      if self.timestamp != 0 {
        try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
      }
      if !self.salt.isEmpty {
        try visitor.visitSingularStringField(value: self.salt, fieldNumber: 4)
      }
      if !self.signature.isEmpty {
        try visitor.visitSingularStringField(value: self.signature, fieldNumber: 5)
      }
      if !self.publicKeyURL.isEmpty {
        try visitor.visitSingularStringField(value: self.publicKeyURL, fieldNumber: 6)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._collationID)
        case 2:
          var v: Server_AuthenticateRequest.Email?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .email(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .email(v)}
        case 3:
          if _storage._id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._id = .facebook(v)}
        case 4:
          if _storage._id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._id = .google(v)}
        case 5:
          var v: Server_AuthenticateRequest.GameCenter?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .gameCenter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .gameCenter(v)}
        case 6:
          if _storage._id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._id = .steam(v)}
        case 7:
          if _storage._id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._id = .device(v)}
        case 8:
          if _storage._id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._id = .custom(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._collationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collationID, fieldNumber: 1)
      }
      switch _storage._id {
      case .email(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .facebook(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      case .google(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      case .gameCenter(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .steam(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      case .device(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      case .custom(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Authentication message wrapper containing either a AuthenticateResponse.Session or AuthenticateResponse.Error.
struct Server_AuthenticateResponse: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".AuthenticateResponse"

  //// Optional collationID to track server response.
  var collationID: String {
    get {return _storage._collationID}
    set {_uniqueStorage()._collationID = newValue}
  }

  //// OneOf authentication response.
  var id: OneOf_ID? {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  //// Authentication session.
  var session: Server_AuthenticateResponse.Session {
    get {
      if case .session(let v)? = _storage._id {return v}
      return Server_AuthenticateResponse.Session()
    }
    set {_uniqueStorage()._id = .session(newValue)}
  }

  //// Authentication error.
  var error: Server_AuthenticateResponse.Error {
    get {
      if case .error(let v)? = _storage._id {return v}
      return Server_AuthenticateResponse.Error()
    }
    set {_uniqueStorage()._id = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  //// OneOf authentication response.
  enum OneOf_ID: Equatable {
    //// Authentication session.
    case session(Server_AuthenticateResponse.Session)
    //// Authentication error.
    case error(Server_AuthenticateResponse.Error)

    static func ==(lhs: Server_AuthenticateResponse.OneOf_ID, rhs: Server_AuthenticateResponse.OneOf_ID) -> Bool {
      switch (lhs, rhs) {
      case (.session(let l), .session(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      default: return false
      }
    }
  }

  ///*
  /// Authentication Session.
  struct Session: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_AuthenticateResponse.protoMessageName + ".Session"

    //// Authentication Token.
    var token: String = String()

    //// UDP token.
    var udpToken: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.token)
        case 2: try decoder.decodeSingularStringField(value: &self.udpToken)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.token.isEmpty {
        try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
      }
      if !self.udpToken.isEmpty {
        try visitor.visitSingularStringField(value: self.udpToken, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  ///*
  /// Authentication Error.
  struct Error: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_AuthenticateResponse.protoMessageName + ".Error"

    //// Error code - this will be the same as the global error codes.
    var code: Int32 {
      get {return _storage._code}
      set {_uniqueStorage()._code = newValue}
    }

    //// Specific error message.
    var message: String {
      get {return _storage._message}
      set {_uniqueStorage()._message = newValue}
    }

    //// Original request that caused this error.
    var request: Server_AuthenticateRequest {
      get {return _storage._request ?? Server_AuthenticateRequest()}
      set {_uniqueStorage()._request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    var hasRequest: Bool {return _storage._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    mutating func clearRequest() {_storage._request = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularInt32Field(value: &_storage._code)
          case 2: try decoder.decodeSingularStringField(value: &_storage._message)
          case 3: try decoder.decodeSingularMessageField(value: &_storage._request)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if _storage._code != 0 {
          try visitor.visitSingularInt32Field(value: _storage._code, fieldNumber: 1)
        }
        if !_storage._message.isEmpty {
          try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
        }
        if let v = _storage._request {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._collationID)
        case 2:
          var v: Server_AuthenticateResponse.Session?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .session(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .session(v)}
        case 3:
          var v: Server_AuthenticateResponse.Error?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .error(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._collationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collationID, fieldNumber: 1)
      }
      switch _storage._id {
      case .session(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Main message wrapper containing a Payload and an optional Collation ID to track server responses.
struct Server_Envelope: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Envelope"

  //// Optional collationID to track server response.
  var collationID: String {
    get {return _storage._collationID}
    set {_uniqueStorage()._collationID = newValue}
  }

  //// OneOf envelope payload. This can be both for request and response purposes.
  var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  var error: Server_Error {
    get {
      if case .error(let v)? = _storage._payload {return v}
      return Server_Error()
    }
    set {_uniqueStorage()._payload = .error(newValue)}
  }

  var heartbeat: Server_Heartbeat {
    get {
      if case .heartbeat(let v)? = _storage._payload {return v}
      return Server_Heartbeat()
    }
    set {_uniqueStorage()._payload = .heartbeat(newValue)}
  }

  var logout: Server_Logout {
    get {
      if case .logout(let v)? = _storage._payload {return v}
      return Server_Logout()
    }
    set {_uniqueStorage()._payload = .logout(newValue)}
  }

  var link: Server_TLink {
    get {
      if case .link(let v)? = _storage._payload {return v}
      return Server_TLink()
    }
    set {_uniqueStorage()._payload = .link(newValue)}
  }

  var unlink: Server_TUnlink {
    get {
      if case .unlink(let v)? = _storage._payload {return v}
      return Server_TUnlink()
    }
    set {_uniqueStorage()._payload = .unlink(newValue)}
  }

  var selfFetch: Server_TSelfFetch {
    get {
      if case .selfFetch(let v)? = _storage._payload {return v}
      return Server_TSelfFetch()
    }
    set {_uniqueStorage()._payload = .selfFetch(newValue)}
  }

  var selfUpdate: Server_TSelfUpdate {
    get {
      if case .selfUpdate(let v)? = _storage._payload {return v}
      return Server_TSelfUpdate()
    }
    set {_uniqueStorage()._payload = .selfUpdate(newValue)}
  }

  var usersFetch: Server_TUsersFetch {
    get {
      if case .usersFetch(let v)? = _storage._payload {return v}
      return Server_TUsersFetch()
    }
    set {_uniqueStorage()._payload = .usersFetch(newValue)}
  }

  var self_p: Server_TSelf {
    get {
      if case .self_p(let v)? = _storage._payload {return v}
      return Server_TSelf()
    }
    set {_uniqueStorage()._payload = .self_p(newValue)}
  }

  var users: Server_TUsers {
    get {
      if case .users(let v)? = _storage._payload {return v}
      return Server_TUsers()
    }
    set {_uniqueStorage()._payload = .users(newValue)}
  }

  var friendsAdd: Server_TFriendsAdd {
    get {
      if case .friendsAdd(let v)? = _storage._payload {return v}
      return Server_TFriendsAdd()
    }
    set {_uniqueStorage()._payload = .friendsAdd(newValue)}
  }

  var friendsRemove: Server_TFriendsRemove {
    get {
      if case .friendsRemove(let v)? = _storage._payload {return v}
      return Server_TFriendsRemove()
    }
    set {_uniqueStorage()._payload = .friendsRemove(newValue)}
  }

  var friendsBlock: Server_TFriendsBlock {
    get {
      if case .friendsBlock(let v)? = _storage._payload {return v}
      return Server_TFriendsBlock()
    }
    set {_uniqueStorage()._payload = .friendsBlock(newValue)}
  }

  var friendsList: Server_TFriendsList {
    get {
      if case .friendsList(let v)? = _storage._payload {return v}
      return Server_TFriendsList()
    }
    set {_uniqueStorage()._payload = .friendsList(newValue)}
  }

  var friends: Server_TFriends {
    get {
      if case .friends(let v)? = _storage._payload {return v}
      return Server_TFriends()
    }
    set {_uniqueStorage()._payload = .friends(newValue)}
  }

  var groupsCreate: Server_TGroupsCreate {
    get {
      if case .groupsCreate(let v)? = _storage._payload {return v}
      return Server_TGroupsCreate()
    }
    set {_uniqueStorage()._payload = .groupsCreate(newValue)}
  }

  var groupsUpdate: Server_TGroupsUpdate {
    get {
      if case .groupsUpdate(let v)? = _storage._payload {return v}
      return Server_TGroupsUpdate()
    }
    set {_uniqueStorage()._payload = .groupsUpdate(newValue)}
  }

  var groupsRemove: Server_TGroupsRemove {
    get {
      if case .groupsRemove(let v)? = _storage._payload {return v}
      return Server_TGroupsRemove()
    }
    set {_uniqueStorage()._payload = .groupsRemove(newValue)}
  }

  var groupsFetch: Server_TGroupsFetch {
    get {
      if case .groupsFetch(let v)? = _storage._payload {return v}
      return Server_TGroupsFetch()
    }
    set {_uniqueStorage()._payload = .groupsFetch(newValue)}
  }

  var groupsList: Server_TGroupsList {
    get {
      if case .groupsList(let v)? = _storage._payload {return v}
      return Server_TGroupsList()
    }
    set {_uniqueStorage()._payload = .groupsList(newValue)}
  }

  var groupsSelfList: Server_TGroupsSelfList {
    get {
      if case .groupsSelfList(let v)? = _storage._payload {return v}
      return Server_TGroupsSelfList()
    }
    set {_uniqueStorage()._payload = .groupsSelfList(newValue)}
  }

  var groupUsersList: Server_TGroupUsersList {
    get {
      if case .groupUsersList(let v)? = _storage._payload {return v}
      return Server_TGroupUsersList()
    }
    set {_uniqueStorage()._payload = .groupUsersList(newValue)}
  }

  var groupsJoin: Server_TGroupsJoin {
    get {
      if case .groupsJoin(let v)? = _storage._payload {return v}
      return Server_TGroupsJoin()
    }
    set {_uniqueStorage()._payload = .groupsJoin(newValue)}
  }

  var groupsLeave: Server_TGroupsLeave {
    get {
      if case .groupsLeave(let v)? = _storage._payload {return v}
      return Server_TGroupsLeave()
    }
    set {_uniqueStorage()._payload = .groupsLeave(newValue)}
  }

  var groupUsersAdd: Server_TGroupUsersAdd {
    get {
      if case .groupUsersAdd(let v)? = _storage._payload {return v}
      return Server_TGroupUsersAdd()
    }
    set {_uniqueStorage()._payload = .groupUsersAdd(newValue)}
  }

  var groupUsersKick: Server_TGroupUsersKick {
    get {
      if case .groupUsersKick(let v)? = _storage._payload {return v}
      return Server_TGroupUsersKick()
    }
    set {_uniqueStorage()._payload = .groupUsersKick(newValue)}
  }

  var groupUsersPromote: Server_TGroupUsersPromote {
    get {
      if case .groupUsersPromote(let v)? = _storage._payload {return v}
      return Server_TGroupUsersPromote()
    }
    set {_uniqueStorage()._payload = .groupUsersPromote(newValue)}
  }

  var groups: Server_TGroups {
    get {
      if case .groups(let v)? = _storage._payload {return v}
      return Server_TGroups()
    }
    set {_uniqueStorage()._payload = .groups(newValue)}
  }

  var groupsSelf: Server_TGroupsSelf {
    get {
      if case .groupsSelf(let v)? = _storage._payload {return v}
      return Server_TGroupsSelf()
    }
    set {_uniqueStorage()._payload = .groupsSelf(newValue)}
  }

  var groupUsers: Server_TGroupUsers {
    get {
      if case .groupUsers(let v)? = _storage._payload {return v}
      return Server_TGroupUsers()
    }
    set {_uniqueStorage()._payload = .groupUsers(newValue)}
  }

  var topicsJoin: Server_TTopicsJoin {
    get {
      if case .topicsJoin(let v)? = _storage._payload {return v}
      return Server_TTopicsJoin()
    }
    set {_uniqueStorage()._payload = .topicsJoin(newValue)}
  }

  var topicsLeave: Server_TTopicsLeave {
    get {
      if case .topicsLeave(let v)? = _storage._payload {return v}
      return Server_TTopicsLeave()
    }
    set {_uniqueStorage()._payload = .topicsLeave(newValue)}
  }

  var topicMessageSend: Server_TTopicMessageSend {
    get {
      if case .topicMessageSend(let v)? = _storage._payload {return v}
      return Server_TTopicMessageSend()
    }
    set {_uniqueStorage()._payload = .topicMessageSend(newValue)}
  }

  var topicMessagesList: Server_TTopicMessagesList {
    get {
      if case .topicMessagesList(let v)? = _storage._payload {return v}
      return Server_TTopicMessagesList()
    }
    set {_uniqueStorage()._payload = .topicMessagesList(newValue)}
  }

  var topics: Server_TTopics {
    get {
      if case .topics(let v)? = _storage._payload {return v}
      return Server_TTopics()
    }
    set {_uniqueStorage()._payload = .topics(newValue)}
  }

  var topicMessageAck: Server_TTopicMessageAck {
    get {
      if case .topicMessageAck(let v)? = _storage._payload {return v}
      return Server_TTopicMessageAck()
    }
    set {_uniqueStorage()._payload = .topicMessageAck(newValue)}
  }

  var topicMessage: Server_TopicMessage {
    get {
      if case .topicMessage(let v)? = _storage._payload {return v}
      return Server_TopicMessage()
    }
    set {_uniqueStorage()._payload = .topicMessage(newValue)}
  }

  var topicMessages: Server_TTopicMessages {
    get {
      if case .topicMessages(let v)? = _storage._payload {return v}
      return Server_TTopicMessages()
    }
    set {_uniqueStorage()._payload = .topicMessages(newValue)}
  }

  var topicPresence: Server_TopicPresence {
    get {
      if case .topicPresence(let v)? = _storage._payload {return v}
      return Server_TopicPresence()
    }
    set {_uniqueStorage()._payload = .topicPresence(newValue)}
  }

  var matchCreate: Server_TMatchCreate {
    get {
      if case .matchCreate(let v)? = _storage._payload {return v}
      return Server_TMatchCreate()
    }
    set {_uniqueStorage()._payload = .matchCreate(newValue)}
  }

  var matchesJoin: Server_TMatchesJoin {
    get {
      if case .matchesJoin(let v)? = _storage._payload {return v}
      return Server_TMatchesJoin()
    }
    set {_uniqueStorage()._payload = .matchesJoin(newValue)}
  }

  var matchesLeave: Server_TMatchesLeave {
    get {
      if case .matchesLeave(let v)? = _storage._payload {return v}
      return Server_TMatchesLeave()
    }
    set {_uniqueStorage()._payload = .matchesLeave(newValue)}
  }

  var matchDataSend: Server_MatchDataSend {
    get {
      if case .matchDataSend(let v)? = _storage._payload {return v}
      return Server_MatchDataSend()
    }
    set {_uniqueStorage()._payload = .matchDataSend(newValue)}
  }

  var match: Server_TMatch {
    get {
      if case .match(let v)? = _storage._payload {return v}
      return Server_TMatch()
    }
    set {_uniqueStorage()._payload = .match(newValue)}
  }

  var matches: Server_TMatches {
    get {
      if case .matches(let v)? = _storage._payload {return v}
      return Server_TMatches()
    }
    set {_uniqueStorage()._payload = .matches(newValue)}
  }

  var matchData: Server_MatchData {
    get {
      if case .matchData(let v)? = _storage._payload {return v}
      return Server_MatchData()
    }
    set {_uniqueStorage()._payload = .matchData(newValue)}
  }

  var matchPresence: Server_MatchPresence {
    get {
      if case .matchPresence(let v)? = _storage._payload {return v}
      return Server_MatchPresence()
    }
    set {_uniqueStorage()._payload = .matchPresence(newValue)}
  }

  var storageList: Server_TStorageList {
    get {
      if case .storageList(let v)? = _storage._payload {return v}
      return Server_TStorageList()
    }
    set {_uniqueStorage()._payload = .storageList(newValue)}
  }

  var storageFetch: Server_TStorageFetch {
    get {
      if case .storageFetch(let v)? = _storage._payload {return v}
      return Server_TStorageFetch()
    }
    set {_uniqueStorage()._payload = .storageFetch(newValue)}
  }

  var storageWrite: Server_TStorageWrite {
    get {
      if case .storageWrite(let v)? = _storage._payload {return v}
      return Server_TStorageWrite()
    }
    set {_uniqueStorage()._payload = .storageWrite(newValue)}
  }

  var storageUpdate: Server_TStorageUpdate {
    get {
      if case .storageUpdate(let v)? = _storage._payload {return v}
      return Server_TStorageUpdate()
    }
    set {_uniqueStorage()._payload = .storageUpdate(newValue)}
  }

  var storageRemove: Server_TStorageRemove {
    get {
      if case .storageRemove(let v)? = _storage._payload {return v}
      return Server_TStorageRemove()
    }
    set {_uniqueStorage()._payload = .storageRemove(newValue)}
  }

  var storageData: Server_TStorageData {
    get {
      if case .storageData(let v)? = _storage._payload {return v}
      return Server_TStorageData()
    }
    set {_uniqueStorage()._payload = .storageData(newValue)}
  }

  var storageKeys: Server_TStorageKeys {
    get {
      if case .storageKeys(let v)? = _storage._payload {return v}
      return Server_TStorageKeys()
    }
    set {_uniqueStorage()._payload = .storageKeys(newValue)}
  }

  var leaderboardsList: Server_TLeaderboardsList {
    get {
      if case .leaderboardsList(let v)? = _storage._payload {return v}
      return Server_TLeaderboardsList()
    }
    set {_uniqueStorage()._payload = .leaderboardsList(newValue)}
  }

  var leaderboardRecordsWrite: Server_TLeaderboardRecordsWrite {
    get {
      if case .leaderboardRecordsWrite(let v)? = _storage._payload {return v}
      return Server_TLeaderboardRecordsWrite()
    }
    set {_uniqueStorage()._payload = .leaderboardRecordsWrite(newValue)}
  }

  var leaderboardRecordsFetch: Server_TLeaderboardRecordsFetch {
    get {
      if case .leaderboardRecordsFetch(let v)? = _storage._payload {return v}
      return Server_TLeaderboardRecordsFetch()
    }
    set {_uniqueStorage()._payload = .leaderboardRecordsFetch(newValue)}
  }

  var leaderboardRecordsList: Server_TLeaderboardRecordsList {
    get {
      if case .leaderboardRecordsList(let v)? = _storage._payload {return v}
      return Server_TLeaderboardRecordsList()
    }
    set {_uniqueStorage()._payload = .leaderboardRecordsList(newValue)}
  }

  var leaderboards: Server_TLeaderboards {
    get {
      if case .leaderboards(let v)? = _storage._payload {return v}
      return Server_TLeaderboards()
    }
    set {_uniqueStorage()._payload = .leaderboards(newValue)}
  }

  var leaderboardRecords: Server_TLeaderboardRecords {
    get {
      if case .leaderboardRecords(let v)? = _storage._payload {return v}
      return Server_TLeaderboardRecords()
    }
    set {_uniqueStorage()._payload = .leaderboardRecords(newValue)}
  }

  var matchmakeAdd: Server_TMatchmakeAdd {
    get {
      if case .matchmakeAdd(let v)? = _storage._payload {return v}
      return Server_TMatchmakeAdd()
    }
    set {_uniqueStorage()._payload = .matchmakeAdd(newValue)}
  }

  var matchmakeRemove: Server_TMatchmakeRemove {
    get {
      if case .matchmakeRemove(let v)? = _storage._payload {return v}
      return Server_TMatchmakeRemove()
    }
    set {_uniqueStorage()._payload = .matchmakeRemove(newValue)}
  }

  var matchmakeTicket: Server_TMatchmakeTicket {
    get {
      if case .matchmakeTicket(let v)? = _storage._payload {return v}
      return Server_TMatchmakeTicket()
    }
    set {_uniqueStorage()._payload = .matchmakeTicket(newValue)}
  }

  var matchmakeMatched: Server_MatchmakeMatched {
    get {
      if case .matchmakeMatched(let v)? = _storage._payload {return v}
      return Server_MatchmakeMatched()
    }
    set {_uniqueStorage()._payload = .matchmakeMatched(newValue)}
  }

  var rpc: Server_TRpc {
    get {
      if case .rpc(let v)? = _storage._payload {return v}
      return Server_TRpc()
    }
    set {_uniqueStorage()._payload = .rpc(newValue)}
  }

  var purchase: Server_TPurchaseValidation {
    get {
      if case .purchase(let v)? = _storage._payload {return v}
      return Server_TPurchaseValidation()
    }
    set {_uniqueStorage()._payload = .purchase(newValue)}
  }

  var purchaseRecord: Server_TPurchaseRecord {
    get {
      if case .purchaseRecord(let v)? = _storage._payload {return v}
      return Server_TPurchaseRecord()
    }
    set {_uniqueStorage()._payload = .purchaseRecord(newValue)}
  }

  var notificationsList: Server_TNotificationsList {
    get {
      if case .notificationsList(let v)? = _storage._payload {return v}
      return Server_TNotificationsList()
    }
    set {_uniqueStorage()._payload = .notificationsList(newValue)}
  }

  var notificationsRemove: Server_TNotificationsRemove {
    get {
      if case .notificationsRemove(let v)? = _storage._payload {return v}
      return Server_TNotificationsRemove()
    }
    set {_uniqueStorage()._payload = .notificationsRemove(newValue)}
  }

  var notifications: Server_TNotifications {
    get {
      if case .notifications(let v)? = _storage._payload {return v}
      return Server_TNotifications()
    }
    set {_uniqueStorage()._payload = .notifications(newValue)}
  }

  var liveNotifications: Server_Notifications {
    get {
      if case .liveNotifications(let v)? = _storage._payload {return v}
      return Server_Notifications()
    }
    set {_uniqueStorage()._payload = .liveNotifications(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  //// OneOf envelope payload. This can be both for request and response purposes.
  enum OneOf_Payload: Equatable {
    case error(Server_Error)
    case heartbeat(Server_Heartbeat)
    case logout(Server_Logout)
    case link(Server_TLink)
    case unlink(Server_TUnlink)
    case selfFetch(Server_TSelfFetch)
    case selfUpdate(Server_TSelfUpdate)
    case usersFetch(Server_TUsersFetch)
    case self_p(Server_TSelf)
    case users(Server_TUsers)
    case friendsAdd(Server_TFriendsAdd)
    case friendsRemove(Server_TFriendsRemove)
    case friendsBlock(Server_TFriendsBlock)
    case friendsList(Server_TFriendsList)
    case friends(Server_TFriends)
    case groupsCreate(Server_TGroupsCreate)
    case groupsUpdate(Server_TGroupsUpdate)
    case groupsRemove(Server_TGroupsRemove)
    case groupsFetch(Server_TGroupsFetch)
    case groupsList(Server_TGroupsList)
    case groupsSelfList(Server_TGroupsSelfList)
    case groupUsersList(Server_TGroupUsersList)
    case groupsJoin(Server_TGroupsJoin)
    case groupsLeave(Server_TGroupsLeave)
    case groupUsersAdd(Server_TGroupUsersAdd)
    case groupUsersKick(Server_TGroupUsersKick)
    case groupUsersPromote(Server_TGroupUsersPromote)
    case groups(Server_TGroups)
    case groupsSelf(Server_TGroupsSelf)
    case groupUsers(Server_TGroupUsers)
    case topicsJoin(Server_TTopicsJoin)
    case topicsLeave(Server_TTopicsLeave)
    case topicMessageSend(Server_TTopicMessageSend)
    case topicMessagesList(Server_TTopicMessagesList)
    case topics(Server_TTopics)
    case topicMessageAck(Server_TTopicMessageAck)
    case topicMessage(Server_TopicMessage)
    case topicMessages(Server_TTopicMessages)
    case topicPresence(Server_TopicPresence)
    case matchCreate(Server_TMatchCreate)
    case matchesJoin(Server_TMatchesJoin)
    case matchesLeave(Server_TMatchesLeave)
    case matchDataSend(Server_MatchDataSend)
    case match(Server_TMatch)
    case matches(Server_TMatches)
    case matchData(Server_MatchData)
    case matchPresence(Server_MatchPresence)
    case storageList(Server_TStorageList)
    case storageFetch(Server_TStorageFetch)
    case storageWrite(Server_TStorageWrite)
    case storageUpdate(Server_TStorageUpdate)
    case storageRemove(Server_TStorageRemove)
    case storageData(Server_TStorageData)
    case storageKeys(Server_TStorageKeys)
    case leaderboardsList(Server_TLeaderboardsList)
    case leaderboardRecordsWrite(Server_TLeaderboardRecordsWrite)
    case leaderboardRecordsFetch(Server_TLeaderboardRecordsFetch)
    case leaderboardRecordsList(Server_TLeaderboardRecordsList)
    case leaderboards(Server_TLeaderboards)
    case leaderboardRecords(Server_TLeaderboardRecords)
    case matchmakeAdd(Server_TMatchmakeAdd)
    case matchmakeRemove(Server_TMatchmakeRemove)
    case matchmakeTicket(Server_TMatchmakeTicket)
    case matchmakeMatched(Server_MatchmakeMatched)
    case rpc(Server_TRpc)
    case purchase(Server_TPurchaseValidation)
    case purchaseRecord(Server_TPurchaseRecord)
    case notificationsList(Server_TNotificationsList)
    case notificationsRemove(Server_TNotificationsRemove)
    case notifications(Server_TNotifications)
    case liveNotifications(Server_Notifications)

    static func ==(lhs: Server_Envelope.OneOf_Payload, rhs: Server_Envelope.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.error(let l), .error(let r)): return l == r
      case (.heartbeat(let l), .heartbeat(let r)): return l == r
      case (.logout(let l), .logout(let r)): return l == r
      case (.link(let l), .link(let r)): return l == r
      case (.unlink(let l), .unlink(let r)): return l == r
      case (.selfFetch(let l), .selfFetch(let r)): return l == r
      case (.selfUpdate(let l), .selfUpdate(let r)): return l == r
      case (.usersFetch(let l), .usersFetch(let r)): return l == r
      case (.self_p(let l), .self_p(let r)): return l == r
      case (.users(let l), .users(let r)): return l == r
      case (.friendsAdd(let l), .friendsAdd(let r)): return l == r
      case (.friendsRemove(let l), .friendsRemove(let r)): return l == r
      case (.friendsBlock(let l), .friendsBlock(let r)): return l == r
      case (.friendsList(let l), .friendsList(let r)): return l == r
      case (.friends(let l), .friends(let r)): return l == r
      case (.groupsCreate(let l), .groupsCreate(let r)): return l == r
      case (.groupsUpdate(let l), .groupsUpdate(let r)): return l == r
      case (.groupsRemove(let l), .groupsRemove(let r)): return l == r
      case (.groupsFetch(let l), .groupsFetch(let r)): return l == r
      case (.groupsList(let l), .groupsList(let r)): return l == r
      case (.groupsSelfList(let l), .groupsSelfList(let r)): return l == r
      case (.groupUsersList(let l), .groupUsersList(let r)): return l == r
      case (.groupsJoin(let l), .groupsJoin(let r)): return l == r
      case (.groupsLeave(let l), .groupsLeave(let r)): return l == r
      case (.groupUsersAdd(let l), .groupUsersAdd(let r)): return l == r
      case (.groupUsersKick(let l), .groupUsersKick(let r)): return l == r
      case (.groupUsersPromote(let l), .groupUsersPromote(let r)): return l == r
      case (.groups(let l), .groups(let r)): return l == r
      case (.groupsSelf(let l), .groupsSelf(let r)): return l == r
      case (.groupUsers(let l), .groupUsers(let r)): return l == r
      case (.topicsJoin(let l), .topicsJoin(let r)): return l == r
      case (.topicsLeave(let l), .topicsLeave(let r)): return l == r
      case (.topicMessageSend(let l), .topicMessageSend(let r)): return l == r
      case (.topicMessagesList(let l), .topicMessagesList(let r)): return l == r
      case (.topics(let l), .topics(let r)): return l == r
      case (.topicMessageAck(let l), .topicMessageAck(let r)): return l == r
      case (.topicMessage(let l), .topicMessage(let r)): return l == r
      case (.topicMessages(let l), .topicMessages(let r)): return l == r
      case (.topicPresence(let l), .topicPresence(let r)): return l == r
      case (.matchCreate(let l), .matchCreate(let r)): return l == r
      case (.matchesJoin(let l), .matchesJoin(let r)): return l == r
      case (.matchesLeave(let l), .matchesLeave(let r)): return l == r
      case (.matchDataSend(let l), .matchDataSend(let r)): return l == r
      case (.match(let l), .match(let r)): return l == r
      case (.matches(let l), .matches(let r)): return l == r
      case (.matchData(let l), .matchData(let r)): return l == r
      case (.matchPresence(let l), .matchPresence(let r)): return l == r
      case (.storageList(let l), .storageList(let r)): return l == r
      case (.storageFetch(let l), .storageFetch(let r)): return l == r
      case (.storageWrite(let l), .storageWrite(let r)): return l == r
      case (.storageUpdate(let l), .storageUpdate(let r)): return l == r
      case (.storageRemove(let l), .storageRemove(let r)): return l == r
      case (.storageData(let l), .storageData(let r)): return l == r
      case (.storageKeys(let l), .storageKeys(let r)): return l == r
      case (.leaderboardsList(let l), .leaderboardsList(let r)): return l == r
      case (.leaderboardRecordsWrite(let l), .leaderboardRecordsWrite(let r)): return l == r
      case (.leaderboardRecordsFetch(let l), .leaderboardRecordsFetch(let r)): return l == r
      case (.leaderboardRecordsList(let l), .leaderboardRecordsList(let r)): return l == r
      case (.leaderboards(let l), .leaderboards(let r)): return l == r
      case (.leaderboardRecords(let l), .leaderboardRecords(let r)): return l == r
      case (.matchmakeAdd(let l), .matchmakeAdd(let r)): return l == r
      case (.matchmakeRemove(let l), .matchmakeRemove(let r)): return l == r
      case (.matchmakeTicket(let l), .matchmakeTicket(let r)): return l == r
      case (.matchmakeMatched(let l), .matchmakeMatched(let r)): return l == r
      case (.rpc(let l), .rpc(let r)): return l == r
      case (.purchase(let l), .purchase(let r)): return l == r
      case (.purchaseRecord(let l), .purchaseRecord(let r)): return l == r
      case (.notificationsList(let l), .notificationsList(let r)): return l == r
      case (.notificationsRemove(let l), .notificationsRemove(let r)): return l == r
      case (.notifications(let l), .notifications(let r)): return l == r
      case (.liveNotifications(let l), .liveNotifications(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._collationID)
        case 2:
          var v: Server_Error?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .error(v)}
        case 3:
          var v: Server_Heartbeat?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .heartbeat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .heartbeat(v)}
        case 4:
          var v: Server_Logout?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .logout(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .logout(v)}
        case 5:
          var v: Server_TLink?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .link(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .link(v)}
        case 6:
          var v: Server_TUnlink?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .unlink(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .unlink(v)}
        case 7:
          var v: Server_TSelfFetch?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .selfFetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .selfFetch(v)}
        case 8:
          var v: Server_TSelfUpdate?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .selfUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .selfUpdate(v)}
        case 9:
          var v: Server_TUsersFetch?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .usersFetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .usersFetch(v)}
        case 10:
          var v: Server_TSelf?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .self_p(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .self_p(v)}
        case 11:
          var v: Server_TUsers?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .users(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .users(v)}
        case 12:
          var v: Server_TFriendsAdd?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .friendsAdd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .friendsAdd(v)}
        case 13:
          var v: Server_TFriendsRemove?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .friendsRemove(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .friendsRemove(v)}
        case 14:
          var v: Server_TFriendsBlock?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .friendsBlock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .friendsBlock(v)}
        case 15:
          var v: Server_TFriendsList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .friendsList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .friendsList(v)}
        case 16:
          var v: Server_TFriends?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .friends(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .friends(v)}
        case 17:
          var v: Server_TGroupsCreate?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsCreate(v)}
        case 18:
          var v: Server_TGroupsUpdate?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsUpdate(v)}
        case 19:
          var v: Server_TGroupsRemove?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsRemove(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsRemove(v)}
        case 20:
          var v: Server_TGroupsFetch?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsFetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsFetch(v)}
        case 21:
          var v: Server_TGroupsList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsList(v)}
        case 22:
          var v: Server_TGroupsSelfList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsSelfList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsSelfList(v)}
        case 23:
          var v: Server_TGroupUsersList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupUsersList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupUsersList(v)}
        case 24:
          var v: Server_TGroupsJoin?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsJoin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsJoin(v)}
        case 25:
          var v: Server_TGroupsLeave?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsLeave(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsLeave(v)}
        case 26:
          var v: Server_TGroupUsersAdd?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupUsersAdd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupUsersAdd(v)}
        case 27:
          var v: Server_TGroupUsersKick?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupUsersKick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupUsersKick(v)}
        case 28:
          var v: Server_TGroupUsersPromote?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupUsersPromote(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupUsersPromote(v)}
        case 29:
          var v: Server_TGroups?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groups(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groups(v)}
        case 30:
          var v: Server_TGroupsSelf?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsSelf(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsSelf(v)}
        case 31:
          var v: Server_TGroupUsers?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupUsers(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupUsers(v)}
        case 32:
          var v: Server_TTopicsJoin?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .topicsJoin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .topicsJoin(v)}
        case 33:
          var v: Server_TTopicsLeave?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .topicsLeave(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .topicsLeave(v)}
        case 34:
          var v: Server_TTopicMessageSend?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .topicMessageSend(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .topicMessageSend(v)}
        case 35:
          var v: Server_TTopicMessagesList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .topicMessagesList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .topicMessagesList(v)}
        case 36:
          var v: Server_TTopics?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .topics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .topics(v)}
        case 37:
          var v: Server_TTopicMessageAck?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .topicMessageAck(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .topicMessageAck(v)}
        case 38:
          var v: Server_TopicMessage?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .topicMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .topicMessage(v)}
        case 39:
          var v: Server_TTopicMessages?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .topicMessages(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .topicMessages(v)}
        case 40:
          var v: Server_TopicPresence?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .topicPresence(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .topicPresence(v)}
        case 41:
          var v: Server_TMatchCreate?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matchCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matchCreate(v)}
        case 42:
          var v: Server_TMatchesJoin?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matchesJoin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matchesJoin(v)}
        case 43:
          var v: Server_TMatchesLeave?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matchesLeave(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matchesLeave(v)}
        case 44:
          var v: Server_MatchDataSend?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matchDataSend(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matchDataSend(v)}
        case 45:
          var v: Server_TMatch?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .match(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .match(v)}
        case 46:
          var v: Server_TMatches?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matches(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matches(v)}
        case 47:
          var v: Server_MatchData?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matchData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matchData(v)}
        case 48:
          var v: Server_MatchPresence?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matchPresence(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matchPresence(v)}
        case 49:
          var v: Server_TStorageList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .storageList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .storageList(v)}
        case 50:
          var v: Server_TStorageFetch?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .storageFetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .storageFetch(v)}
        case 51:
          var v: Server_TStorageWrite?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .storageWrite(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .storageWrite(v)}
        case 52:
          var v: Server_TStorageUpdate?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .storageUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .storageUpdate(v)}
        case 53:
          var v: Server_TStorageRemove?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .storageRemove(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .storageRemove(v)}
        case 54:
          var v: Server_TStorageData?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .storageData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .storageData(v)}
        case 55:
          var v: Server_TStorageKeys?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .storageKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .storageKeys(v)}
        case 56:
          var v: Server_TLeaderboardsList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .leaderboardsList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .leaderboardsList(v)}
        case 57:
          var v: Server_TLeaderboardRecordsWrite?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .leaderboardRecordsWrite(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .leaderboardRecordsWrite(v)}
        case 58:
          var v: Server_TLeaderboardRecordsFetch?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .leaderboardRecordsFetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .leaderboardRecordsFetch(v)}
        case 59:
          var v: Server_TLeaderboardRecordsList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .leaderboardRecordsList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .leaderboardRecordsList(v)}
        case 60:
          var v: Server_TLeaderboards?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .leaderboards(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .leaderboards(v)}
        case 61:
          var v: Server_TLeaderboardRecords?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .leaderboardRecords(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .leaderboardRecords(v)}
        case 62:
          var v: Server_TMatchmakeAdd?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matchmakeAdd(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matchmakeAdd(v)}
        case 63:
          var v: Server_TMatchmakeRemove?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matchmakeRemove(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matchmakeRemove(v)}
        case 64:
          var v: Server_TMatchmakeTicket?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matchmakeTicket(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matchmakeTicket(v)}
        case 65:
          var v: Server_MatchmakeMatched?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .matchmakeMatched(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .matchmakeMatched(v)}
        case 66:
          var v: Server_TRpc?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .rpc(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .rpc(v)}
        case 67:
          var v: Server_TPurchaseValidation?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .purchase(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .purchase(v)}
        case 68:
          var v: Server_TPurchaseRecord?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .purchaseRecord(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .purchaseRecord(v)}
        case 69:
          var v: Server_TNotificationsList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .notificationsList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .notificationsList(v)}
        case 70:
          var v: Server_TNotificationsRemove?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .notificationsRemove(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .notificationsRemove(v)}
        case 71:
          var v: Server_TNotifications?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .notifications(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .notifications(v)}
        case 72:
          var v: Server_Notifications?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .liveNotifications(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .liveNotifications(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._collationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collationID, fieldNumber: 1)
      }
      switch _storage._payload {
      case .error(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .heartbeat(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .logout(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .link(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .unlink(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .selfFetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .selfUpdate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .usersFetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .self_p(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .users(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .friendsAdd(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .friendsRemove(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .friendsBlock(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .friendsList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .friends(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .groupsCreate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .groupsUpdate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .groupsRemove(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .groupsFetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .groupsList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .groupsSelfList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .groupUsersList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .groupsJoin(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .groupsLeave(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .groupUsersAdd(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .groupUsersKick(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case .groupUsersPromote(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      case .groups(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      case .groupsSelf(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case .groupUsers(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      case .topicsJoin(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      case .topicsLeave(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      case .topicMessageSend(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      case .topicMessagesList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      case .topics(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      case .topicMessageAck(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      case .topicMessage(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      case .topicMessages(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      case .topicPresence(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      case .matchCreate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      case .matchesJoin(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      case .matchesLeave(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      case .matchDataSend(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      case .match(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      case .matches(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      case .matchData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      case .matchPresence(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      case .storageList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      case .storageFetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      case .storageWrite(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      case .storageUpdate(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      case .storageRemove(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      case .storageData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      case .storageKeys(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      case .leaderboardsList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      case .leaderboardRecordsWrite(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      case .leaderboardRecordsFetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      case .leaderboardRecordsList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      case .leaderboards(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      case .leaderboardRecords(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      case .matchmakeAdd(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      case .matchmakeRemove(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      case .matchmakeTicket(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      case .matchmakeMatched(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
      case .rpc(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      case .purchase(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      case .purchaseRecord(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      case .notificationsList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
      case .notificationsRemove(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      case .notifications(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      case .liveNotifications(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Logout message used to gracefully disconnect the client from the server.
/// It will also blacklist the authentication session token.
struct Server_Logout: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Logout"

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TLink message is used to link a profile with a user account
/// It expects same input as an authentication.
struct Server_TLink: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TLink"

  //// OneOf linking methods.
  var id: OneOf_ID? {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  //// Email address and password.
  var email: Server_AuthenticateRequest.Email {
    get {
      if case .email(let v)? = _storage._id {return v}
      return Server_AuthenticateRequest.Email()
    }
    set {_uniqueStorage()._id = .email(newValue)}
  }

  //// Facebook OAuth Access Token.
  var facebook: String {
    get {
      if case .facebook(let v)? = _storage._id {return v}
      return String()
    }
    set {_uniqueStorage()._id = .facebook(newValue)}
  }

  //// Google OAuth Access Token.
  var google: String {
    get {
      if case .google(let v)? = _storage._id {return v}
      return String()
    }
    set {_uniqueStorage()._id = .google(newValue)}
  }

  //// GameCenter.
  var gameCenter: Server_AuthenticateRequest.GameCenter {
    get {
      if case .gameCenter(let v)? = _storage._id {return v}
      return Server_AuthenticateRequest.GameCenter()
    }
    set {_uniqueStorage()._id = .gameCenter(newValue)}
  }

  //// Steam Token.
  var steam: String {
    get {
      if case .steam(let v)? = _storage._id {return v}
      return String()
    }
    set {_uniqueStorage()._id = .steam(newValue)}
  }

  //// Device ID.
  var device: String {
    get {
      if case .device(let v)? = _storage._id {return v}
      return String()
    }
    set {_uniqueStorage()._id = .device(newValue)}
  }

  //// Custom ID.
  var custom: String {
    get {
      if case .custom(let v)? = _storage._id {return v}
      return String()
    }
    set {_uniqueStorage()._id = .custom(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  //// OneOf linking methods.
  enum OneOf_ID: Equatable {
    //// Email address and password.
    case email(Server_AuthenticateRequest.Email)
    //// Facebook OAuth Access Token.
    case facebook(String)
    //// Google OAuth Access Token.
    case google(String)
    //// GameCenter.
    case gameCenter(Server_AuthenticateRequest.GameCenter)
    //// Steam Token.
    case steam(String)
    //// Device ID.
    case device(String)
    //// Custom ID.
    case custom(String)

    static func ==(lhs: Server_TLink.OneOf_ID, rhs: Server_TLink.OneOf_ID) -> Bool {
      switch (lhs, rhs) {
      case (.email(let l), .email(let r)): return l == r
      case (.facebook(let l), .facebook(let r)): return l == r
      case (.google(let l), .google(let r)): return l == r
      case (.gameCenter(let l), .gameCenter(let r)): return l == r
      case (.steam(let l), .steam(let r)): return l == r
      case (.device(let l), .device(let r)): return l == r
      case (.custom(let l), .custom(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Server_AuthenticateRequest.Email?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .email(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .email(v)}
        case 2:
          if _storage._id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._id = .facebook(v)}
        case 3:
          if _storage._id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._id = .google(v)}
        case 4:
          var v: Server_AuthenticateRequest.GameCenter?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .gameCenter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .gameCenter(v)}
        case 5:
          if _storage._id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._id = .steam(v)}
        case 6:
          if _storage._id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._id = .device(v)}
        case 7:
          if _storage._id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._id = .custom(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._id {
      case .email(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .facebook(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .google(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      case .gameCenter(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .steam(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      case .device(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      case .custom(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TUnlink message is used to unlink a profile with a user account
/// Unlink allows direct IDs, no tokens needed.
struct Server_TUnlink: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TUnlink"

  //// OneOf unlinking methods.
  var id: Server_TUnlink.OneOf_ID? = nil

  //// Email address.
  var email: String {
    get {
      if case .email(let v)? = id {return v}
      return String()
    }
    set {id = .email(newValue)}
  }

  //// Facebook ID.
  var facebook: String {
    get {
      if case .facebook(let v)? = id {return v}
      return String()
    }
    set {id = .facebook(newValue)}
  }

  //// Google ID.
  var google: String {
    get {
      if case .google(let v)? = id {return v}
      return String()
    }
    set {id = .google(newValue)}
  }

  //// GameCenter ID.
  var gameCenter: String {
    get {
      if case .gameCenter(let v)? = id {return v}
      return String()
    }
    set {id = .gameCenter(newValue)}
  }

  //// Steam ID.
  var steam: String {
    get {
      if case .steam(let v)? = id {return v}
      return String()
    }
    set {id = .steam(newValue)}
  }

  //// Device ID.
  var device: String {
    get {
      if case .device(let v)? = id {return v}
      return String()
    }
    set {id = .device(newValue)}
  }

  //// Custom ID.
  var custom: String {
    get {
      if case .custom(let v)? = id {return v}
      return String()
    }
    set {id = .custom(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  //// OneOf unlinking methods.
  enum OneOf_ID: Equatable {
    //// Email address.
    case email(String)
    //// Facebook ID.
    case facebook(String)
    //// Google ID.
    case google(String)
    //// GameCenter ID.
    case gameCenter(String)
    //// Steam ID.
    case steam(String)
    //// Device ID.
    case device(String)
    //// Custom ID.
    case custom(String)

    static func ==(lhs: Server_TUnlink.OneOf_ID, rhs: Server_TUnlink.OneOf_ID) -> Bool {
      switch (lhs, rhs) {
      case (.email(let l), .email(let r)): return l == r
      case (.facebook(let l), .facebook(let r)): return l == r
      case (.google(let l), .google(let r)): return l == r
      case (.gameCenter(let l), .gameCenter(let r)): return l == r
      case (.steam(let l), .steam(let r)): return l == r
      case (.device(let l), .device(let r)): return l == r
      case (.custom(let l), .custom(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .email(v)}
      case 2:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .facebook(v)}
      case 3:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .google(v)}
      case 4:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .gameCenter(v)}
      case 5:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .steam(v)}
      case 6:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .device(v)}
      case 7:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .custom(v)}
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.id {
    case .email(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .facebook(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .google(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case .gameCenter(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    case .steam(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    case .device(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    case .custom(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// User is the core domain type representing a user in Nakama.
struct Server_User: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".User"

  //// User ID.
  var id: String = String()

  //// User Handle (username).
  var handle: String = String()

  //// User's fullname.
  var fullname: String = String()

  //// Link to avatar.
  var avatarURL: String = String()

  //// Language tag corresponding to the BCP 47 spec.
  var lang: String = String()

  //// User's location.
  var location: String = String()

  //// User's timezone.
  var timezone: String = String()

  //// Custom user metadata.
  var metadata: String = String()

  //// Unix timestamp when this user registered.
  var createdAt: Int64 = 0

  //// Unix timestamp when user profile was last changed.
  var updatedAt: Int64 = 0

  //// Unix timestamp when user was last connected.
  var lastOnlineAt: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.handle)
      case 3: try decoder.decodeSingularStringField(value: &self.fullname)
      case 4: try decoder.decodeSingularStringField(value: &self.avatarURL)
      case 5: try decoder.decodeSingularStringField(value: &self.lang)
      case 6: try decoder.decodeSingularStringField(value: &self.location)
      case 7: try decoder.decodeSingularStringField(value: &self.timezone)
      case 8: try decoder.decodeSingularStringField(value: &self.metadata)
      case 9: try decoder.decodeSingularInt64Field(value: &self.createdAt)
      case 10: try decoder.decodeSingularInt64Field(value: &self.updatedAt)
      case 11: try decoder.decodeSingularInt64Field(value: &self.lastOnlineAt)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.handle.isEmpty {
      try visitor.visitSingularStringField(value: self.handle, fieldNumber: 2)
    }
    if !self.fullname.isEmpty {
      try visitor.visitSingularStringField(value: self.fullname, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if !self.lang.isEmpty {
      try visitor.visitSingularStringField(value: self.lang, fieldNumber: 5)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 6)
    }
    if !self.timezone.isEmpty {
      try visitor.visitSingularStringField(value: self.timezone, fieldNumber: 7)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 8)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularInt64Field(value: self.createdAt, fieldNumber: 9)
    }
    if self.updatedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.updatedAt, fieldNumber: 10)
    }
    if self.lastOnlineAt != 0 {
      try visitor.visitSingularInt64Field(value: self.lastOnlineAt, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Self is the core domain type representing the currently connected user in Nakama.
/// Alongside the normal user properties, it also contains various other fields only relevant for the current user.
struct Server_Self: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Self"

  //// User's account.
  var user: Server_User {
    get {return _storage._user ?? Server_User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_storage._user = nil}

  //// Whether the user was verified, either via email or social accounts.
  var verified: Bool {
    get {return _storage._verified}
    set {_uniqueStorage()._verified = newValue}
  }

  //// User's email address.
  var email: String {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  //// List of device IDs the user has.
  var deviceIds: [String] {
    get {return _storage._deviceIds}
    set {_uniqueStorage()._deviceIds = newValue}
  }

  //// User's Facebook ID.
  var facebookID: String {
    get {return _storage._facebookID}
    set {_uniqueStorage()._facebookID = newValue}
  }

  //// User's Google ID.
  var googleID: String {
    get {return _storage._googleID}
    set {_uniqueStorage()._googleID = newValue}
  }

  //// User's Game Center ID.
  var gamecenterID: String {
    get {return _storage._gamecenterID}
    set {_uniqueStorage()._gamecenterID = newValue}
  }

  //// User's Steam ID.
  var steamID: String {
    get {return _storage._steamID}
    set {_uniqueStorage()._steamID = newValue}
  }

  //// Custom ID associated with the user.
  var customID: String {
    get {return _storage._customID}
    set {_uniqueStorage()._customID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._verified)
        case 3: try decoder.decodeSingularStringField(value: &_storage._email)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._deviceIds)
        case 5: try decoder.decodeSingularStringField(value: &_storage._facebookID)
        case 6: try decoder.decodeSingularStringField(value: &_storage._googleID)
        case 7: try decoder.decodeSingularStringField(value: &_storage._gamecenterID)
        case 8: try decoder.decodeSingularStringField(value: &_storage._steamID)
        case 9: try decoder.decodeSingularStringField(value: &_storage._customID)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._verified != false {
        try visitor.visitSingularBoolField(value: _storage._verified, fieldNumber: 2)
      }
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 3)
      }
      if !_storage._deviceIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._deviceIds, fieldNumber: 4)
      }
      if !_storage._facebookID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._facebookID, fieldNumber: 5)
      }
      if !_storage._googleID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._googleID, fieldNumber: 6)
      }
      if !_storage._gamecenterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gamecenterID, fieldNumber: 7)
      }
      if !_storage._steamID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._steamID, fieldNumber: 8)
      }
      if !_storage._customID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customID, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TSelfFetch message is used to send a request to retrieve the user account associated with the currently connected user.
///
/// @returns TSelf
struct Server_TSelfFetch: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TSelfFetch"

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TSelf is the user account and any other associated IDs with the user.
struct Server_TSelf: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TSelf"

  var self_p: Server_Self {
    get {return _storage._self_p ?? Server_Self()}
    set {_uniqueStorage()._self_p = newValue}
  }
  /// Returns true if `self_p` has been explicitly set.
  var hasSelf_p: Bool {return _storage._self_p != nil}
  /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
  mutating func clearSelf_p() {_storage._self_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._self_p)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._self_p {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TSelfUpdate message is used to update parts of the user account associated with the currently connected user.
struct Server_TSelfUpdate: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TSelfUpdate"

  var handle: String = String()

  var fullname: String = String()

  var timezone: String = String()

  var location: String = String()

  //// Language tag corresponding to the BCP 47 spec
  var lang: String = String()

  //// Set or remove User's metadata
  var metadata: String = String()

  var avatarURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.handle)
      case 2: try decoder.decodeSingularStringField(value: &self.fullname)
      case 3: try decoder.decodeSingularStringField(value: &self.timezone)
      case 4: try decoder.decodeSingularStringField(value: &self.location)
      case 5: try decoder.decodeSingularStringField(value: &self.lang)
      case 6: try decoder.decodeSingularStringField(value: &self.metadata)
      case 7: try decoder.decodeSingularStringField(value: &self.avatarURL)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.handle.isEmpty {
      try visitor.visitSingularStringField(value: self.handle, fieldNumber: 1)
    }
    if !self.fullname.isEmpty {
      try visitor.visitSingularStringField(value: self.fullname, fieldNumber: 2)
    }
    if !self.timezone.isEmpty {
      try visitor.visitSingularStringField(value: self.timezone, fieldNumber: 3)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 4)
    }
    if !self.lang.isEmpty {
      try visitor.visitSingularStringField(value: self.lang, fieldNumber: 5)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 6)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TUsersFetch fetches a list of users that match the given set of user IDs or user Handles.
///
/// @returns TUsers
struct Server_TUsersFetch: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TUsersFetch"

  //// Must at least contain one item.
  var users: [Server_TUsersFetch.UsersFetch] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct UsersFetch: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TUsersFetch.protoMessageName + ".UsersFetch"

    var id: Server_TUsersFetch.UsersFetch.OneOf_ID? = nil

    var userID: String {
      get {
        if case .userID(let v)? = id {return v}
        return String()
      }
      set {id = .userID(newValue)}
    }

    var handle: String {
      get {
        if case .handle(let v)? = id {return v}
        return String()
      }
      set {id = .handle(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ID: Equatable {
      case userID(String)
      case handle(String)

      static func ==(lhs: Server_TUsersFetch.UsersFetch.OneOf_ID, rhs: Server_TUsersFetch.UsersFetch.OneOf_ID) -> Bool {
        switch (lhs, rhs) {
        case (.userID(let l), .userID(let r)): return l == r
        case (.handle(let l), .handle(let r)): return l == r
        default: return false
        }
      }
    }

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .userID(v)}
        case 2:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .handle(v)}
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      switch self.id {
      case .userID(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .handle(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case nil: break
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.users)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TUsers contains a list of Users. The list could be empty.
struct Server_TUsers: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TUsers"

  var users: [Server_User] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.users)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Friend is the core domain type representing a friend relationship in Nakama.
struct Server_Friend: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Friend"

  //// The user that is the friend of the currently connected user.
  var user: Server_User {
    get {return _storage._user ?? Server_User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_storage._user = nil}

  //// The type of relationship this is. The value can be one of the following:
  //// Friend(0): Mutual friendship.
  //// Invite(1): Current user has sent an invitation.
  //// Invited(2): Current user has received an invitation.
  //// Blocked(3): Current user has blocked this friend.
  var state: Int64 {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._state)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._state != 0 {
        try visitor.visitSingularInt64Field(value: _storage._state, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TFriendsAdd sends a list of user IDs or handles to the server that the current user would like to form a friendship with.
/// If a reverse relationship already exists, then a mutual friendship is formed, otherwise a friendship request is recorded for the user.
struct Server_TFriendsAdd: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TFriendsAdd"

  var friends: [Server_TFriendsAdd.FriendsAdd] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct FriendsAdd: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TFriendsAdd.protoMessageName + ".FriendsAdd"

    var id: Server_TFriendsAdd.FriendsAdd.OneOf_ID? = nil

    var userID: String {
      get {
        if case .userID(let v)? = id {return v}
        return String()
      }
      set {id = .userID(newValue)}
    }

    var handle: String {
      get {
        if case .handle(let v)? = id {return v}
        return String()
      }
      set {id = .handle(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ID: Equatable {
      case userID(String)
      case handle(String)

      static func ==(lhs: Server_TFriendsAdd.FriendsAdd.OneOf_ID, rhs: Server_TFriendsAdd.FriendsAdd.OneOf_ID) -> Bool {
        switch (lhs, rhs) {
        case (.userID(let l), .userID(let r)): return l == r
        case (.handle(let l), .handle(let r)): return l == r
        default: return false
        }
      }
    }

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .userID(v)}
        case 2:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .handle(v)}
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      switch self.id {
      case .userID(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .handle(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case nil: break
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.friends)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.friends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.friends, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TFriendsRemove sends a list of user IDs or handles to the server that the current user would like to remove relationship status from.
/// This could be unfriending a friend, or removing a friend request.
struct Server_TFriendsRemove: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TFriendsRemove"

  var userIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.userIds)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TFriendsBlock sends a list of user IDs or handles to the server that the current user would like to block.
/// If the current user is a friend, relationship is removed bidirectionaly from both users and a new Block status is formed.
struct Server_TFriendsBlock: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TFriendsBlock"

  var userIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.userIds)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TFriendsList fetches a list of users that have a relationship with the current user.
///
/// @returns TFriends
struct Server_TFriendsList: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TFriendsList"

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TUsers contains a list of Friends. The list could be empty.
struct Server_TFriends: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TFriends"

  var friends: [Server_Friend] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.friends)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.friends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.friends, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Group is the core domain type representing a group of users in Nakama.
struct Server_Group: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Group"

  //// Group ID
  var id: String = String()

  //// Whether the group is private or public. If private, group admins will accept user join requests.
  var `private`: Bool = false

  //// User ID of the group creator.
  var creatorID: String = String()

  var name: String = String()

  var description_p: String = String()

  var avatarURL: String = String()

  //// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
  var lang: String = String()

  //// Offset time in millisecond from UTC.
  var utcOffsetMs: Int64 = 0

  //// Group metadata information.
  var metadata: String = String()

  //// Current number of users in this group.
  var count: Int64 = 0

  var createdAt: Int64 = 0

  var updatedAt: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularBoolField(value: &self.`private`)
      case 3: try decoder.decodeSingularStringField(value: &self.creatorID)
      case 4: try decoder.decodeSingularStringField(value: &self.name)
      case 5: try decoder.decodeSingularStringField(value: &self.description_p)
      case 6: try decoder.decodeSingularStringField(value: &self.avatarURL)
      case 7: try decoder.decodeSingularStringField(value: &self.lang)
      case 8: try decoder.decodeSingularInt64Field(value: &self.utcOffsetMs)
      case 9: try decoder.decodeSingularStringField(value: &self.metadata)
      case 10: try decoder.decodeSingularInt64Field(value: &self.count)
      case 11: try decoder.decodeSingularInt64Field(value: &self.createdAt)
      case 12: try decoder.decodeSingularInt64Field(value: &self.updatedAt)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.`private` != false {
      try visitor.visitSingularBoolField(value: self.`private`, fieldNumber: 2)
    }
    if !self.creatorID.isEmpty {
      try visitor.visitSingularStringField(value: self.creatorID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 6)
    }
    if !self.lang.isEmpty {
      try visitor.visitSingularStringField(value: self.lang, fieldNumber: 7)
    }
    if self.utcOffsetMs != 0 {
      try visitor.visitSingularInt64Field(value: self.utcOffsetMs, fieldNumber: 8)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 9)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 10)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularInt64Field(value: self.createdAt, fieldNumber: 11)
    }
    if self.updatedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.updatedAt, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupsCreate creates a new group.
///
/// @returns TGroups
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TGroupsCreate: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupsCreate"

  var groups: [Server_TGroupsCreate.GroupCreate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GroupCreate: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TGroupsCreate.protoMessageName + ".GroupCreate"

    //// Group name must be unique.
    var name: String = String()

    var description_p: String = String()

    var avatarURL: String = String()

    //// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
    var lang: String = String()

    //// Group metadata information.
    var metadata: String = String()

    //// Whether the group is private or public. If private, group admins will accept user join requests.
    var `private`: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.name)
        case 2: try decoder.decodeSingularStringField(value: &self.description_p)
        case 3: try decoder.decodeSingularStringField(value: &self.avatarURL)
        case 4: try decoder.decodeSingularStringField(value: &self.lang)
        case 5: try decoder.decodeSingularStringField(value: &self.metadata)
        case 6: try decoder.decodeSingularBoolField(value: &self.`private`)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.name.isEmpty {
        try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
      }
      if !self.description_p.isEmpty {
        try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
      }
      if !self.avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
      }
      if !self.lang.isEmpty {
        try visitor.visitSingularStringField(value: self.lang, fieldNumber: 4)
      }
      if !self.metadata.isEmpty {
        try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 5)
      }
      if self.`private` != false {
        try visitor.visitSingularBoolField(value: self.`private`, fieldNumber: 6)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groups)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupsUpdate updates the group with matching Group ID.
/// Only group admins can update group information.
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TGroupsUpdate: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupsUpdate"

  var groups: [Server_TGroupsUpdate.GroupUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GroupUpdate: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TGroupsUpdate.protoMessageName + ".GroupUpdate"

    var groupID: String = String()

    //// Whether the group is private or public. If private, group admins will accept user join requests.
    var `private`: Bool = false

    //// Group name must be unique.
    var name: String = String()

    var description_p: String = String()

    var avatarURL: String = String()

    //// Language tag corresponding to the BCP 47 spec. This is important and used for Group search.
    var lang: String = String()

    //// Set or remove metadata information.
    var metadata: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.groupID)
        case 2: try decoder.decodeSingularBoolField(value: &self.`private`)
        case 3: try decoder.decodeSingularStringField(value: &self.name)
        case 4: try decoder.decodeSingularStringField(value: &self.description_p)
        case 5: try decoder.decodeSingularStringField(value: &self.avatarURL)
        case 6: try decoder.decodeSingularStringField(value: &self.lang)
        case 7: try decoder.decodeSingularStringField(value: &self.metadata)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.groupID.isEmpty {
        try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
      }
      if self.`private` != false {
        try visitor.visitSingularBoolField(value: self.`private`, fieldNumber: 2)
      }
      if !self.name.isEmpty {
        try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
      }
      if !self.description_p.isEmpty {
        try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
      }
      if !self.avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 5)
      }
      if !self.lang.isEmpty {
        try visitor.visitSingularStringField(value: self.lang, fieldNumber: 6)
      }
      if !self.metadata.isEmpty {
        try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 7)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groups)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupsRemove removes the group with matching Group ID.
/// Only group admins can delete group.
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TGroupsRemove: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupsRemove"

  var groupIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.groupIds)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.groupIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupsSelfList fetches a list of groups that the current user is part of.
///
/// @returns TGroupsSelf
struct Server_TGroupsSelfList: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupsSelfList"

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupsFetch fetches a list of groups that the match the group ID or group name.
///
/// @returns TGroups
struct Server_TGroupsFetch: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupsFetch"

  var groups: [Server_TGroupsFetch.GroupFetch] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GroupFetch: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TGroupsFetch.protoMessageName + ".GroupFetch"

    var id: Server_TGroupsFetch.GroupFetch.OneOf_ID? = nil

    var groupID: String {
      get {
        if case .groupID(let v)? = id {return v}
        return String()
      }
      set {id = .groupID(newValue)}
    }

    var name: String {
      get {
        if case .name(let v)? = id {return v}
        return String()
      }
      set {id = .name(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ID: Equatable {
      case groupID(String)
      case name(String)

      static func ==(lhs: Server_TGroupsFetch.GroupFetch.OneOf_ID, rhs: Server_TGroupsFetch.GroupFetch.OneOf_ID) -> Bool {
        switch (lhs, rhs) {
        case (.groupID(let l), .groupID(let r)): return l == r
        case (.name(let l), .name(let r)): return l == r
        default: return false
        }
      }
    }

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .groupID(v)}
        case 2:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .name(v)}
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      switch self.id {
      case .groupID(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .name(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case nil: break
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groups)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupsList searches all groups for matching criteria.
///
/// @returns TGroups
struct Server_TGroupsList: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupsList"

  //// Upper limit on the maximum number of groups to return per request. Max value is 100.
  var pageLimit: Int64 = 0

  //// Whether to order the result ascending or descending based on the filters defined below.
  var orderByAsc: Bool = false

  //// Filter used to search for groups.
  var filter: Server_TGroupsList.OneOf_Filter? = nil

  //// Find groups matching the given language tag.
  var lang: String {
    get {
      if case .lang(let v)? = filter {return v}
      return String()
    }
    set {filter = .lang(newValue)}
  }

  //// Find groups created after a given time.
  var createdAt: Int64 {
    get {
      if case .createdAt(let v)? = filter {return v}
      return 0
    }
    set {filter = .createdAt(newValue)}
  }

  //// Find groups that have members up to (and equal to) the count value.
  var count: Int64 {
    get {
      if case .count(let v)? = filter {return v}
      return 0
    }
    set {filter = .count(newValue)}
  }

  //// Binary cursor value used to paginate results.
  //// The value of this comes from TGroups.cursor.
  var cursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  //// Filter used to search for groups.
  enum OneOf_Filter: Equatable {
    //// Find groups matching the given language tag.
    case lang(String)
    //// Find groups created after a given time.
    case createdAt(Int64)
    //// Find groups that have members up to (and equal to) the count value.
    case count(Int64)

    static func ==(lhs: Server_TGroupsList.OneOf_Filter, rhs: Server_TGroupsList.OneOf_Filter) -> Bool {
      switch (lhs, rhs) {
      case (.lang(let l), .lang(let r)): return l == r
      case (.createdAt(let l), .createdAt(let r)): return l == r
      case (.count(let l), .count(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.pageLimit)
      case 2: try decoder.decodeSingularBoolField(value: &self.orderByAsc)
      case 3:
        if self.filter != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.filter = .lang(v)}
      case 4:
        if self.filter != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.filter = .createdAt(v)}
      case 5:
        if self.filter != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.filter = .count(v)}
      case 7: try decoder.decodeSingularStringField(value: &self.cursor)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.pageLimit, fieldNumber: 1)
    }
    if self.orderByAsc != false {
      try visitor.visitSingularBoolField(value: self.orderByAsc, fieldNumber: 2)
    }
    switch self.filter {
    case .lang(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case .createdAt(let v)?:
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    case .count(let v)?:
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    case nil: break
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroups contains a list of groups and a cursor that can be used to further paginate results.
struct Server_TGroups: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroups"

  var groups: [Server_Group] = []

  //// Use cursor to paginate results.
  var cursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groups)
      case 2: try decoder.decodeSingularStringField(value: &self.cursor)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupsSelf contains a list of groups a particular user belongs to, and the user's relationsip to each.
struct Server_TGroupsSelf: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupsSelf"

  var groupsSelf: [Server_TGroupsSelf.GroupSelf] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GroupSelf: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TGroupsSelf.protoMessageName + ".GroupSelf"

    //// The core group information.
    var group: Server_Group {
      get {return _storage._group ?? Server_Group()}
      set {_uniqueStorage()._group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    var hasGroup: Bool {return _storage._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    mutating func clearGroup() {_storage._group = nil}

    //// The user's relationship to the group. One of:
    //// Admin(0): User is an admin for this group.
    //// Member(1): User is a regular member of this group.
    //// Join(2): User is currently waiting to be accepted in this group.
    var state: Int64 {
      get {return _storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularMessageField(value: &_storage._group)
          case 2: try decoder.decodeSingularInt64Field(value: &_storage._state)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if let v = _storage._group {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if _storage._state != 0 {
          try visitor.visitSingularInt64Field(value: _storage._state, fieldNumber: 2)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groupsSelf)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupsSelf.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupsSelf, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// GroupUser is the core domain type representing a user that belongs to a group and their relationship status with the group.
struct Server_GroupUser: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".GroupUser"

  var user: Server_User {
    get {return _storage._user ?? Server_User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_storage._user = nil}

  //// The type of relationship this is. The value can be one of the following:
  //// Admin(0): User is an admin for this group.
  //// Member(1): User is a regular member of this group.
  //// Join(2): User is currently waiting to be accepted in this group.
  var state: Int64 {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._state)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._state != 0 {
        try visitor.visitSingularInt64Field(value: _storage._state, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TGroupsList fetches list of users in the given group.
///
/// @returns TGroupUsers
struct Server_TGroupUsersList: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupUsersList"

  var groupID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.groupID)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupUsers contains all users and their relationship in a group.
struct Server_TGroupUsers: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupUsers"

  var users: [Server_GroupUser] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.users)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupsJoin adds the currently connected user to the groups below.
/// If the group is private, they are added to a waiting queue until a group admin accepts or reject the request.
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TGroupsJoin: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupsJoin"

  var groupIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.groupIds)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.groupIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupsLeave removes the currently connected user from group below.
/// The user won't be able to leave if they are last admin, instead delete the group.
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TGroupsLeave: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupsLeave"

  var groupIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.groupIds)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.groupIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupUsersAdd adds a list of users to a list of groups by the currently connected user.
/// The current user must be an admin of *ALL* groups otherwise the request fails.
/// This is also the way to accept a group join request.
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TGroupUsersAdd: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupUsersAdd"

  var groupUsers: [Server_TGroupUsersAdd.GroupUserAdd] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GroupUserAdd: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TGroupUsersAdd.protoMessageName + ".GroupUserAdd"

    var groupID: String = String()

    var userID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.groupID)
        case 2: try decoder.decodeSingularStringField(value: &self.userID)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.groupID.isEmpty {
        try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
      }
      if !self.userID.isEmpty {
        try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groupUsers)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupUsers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupUsers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupUsersKick removes a list of users from a list of groups by the currently connected user.
/// The current user must be an admin of *ALL* groups otherwise the request fails.
/// This is also the way to reject a group join request.
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TGroupUsersKick: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupUsersKick"

  var groupUsers: [Server_TGroupUsersKick.GroupUserKick] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GroupUserKick: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TGroupUsersKick.protoMessageName + ".GroupUserKick"

    var groupID: String = String()

    var userID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.groupID)
        case 2: try decoder.decodeSingularStringField(value: &self.userID)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.groupID.isEmpty {
        try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
      }
      if !self.userID.isEmpty {
        try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groupUsers)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupUsers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupUsers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TGroupUsersPromote updates a list of regular users to have group admin priviliges for a list of groups by the currently connected user.
/// The current user must be an admin of *ALL* groups otherwise the request fails.
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TGroupUsersPromote: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TGroupUsersPromote"

  var groupUsers: [Server_TGroupUsersPromote.GroupUserPromote] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GroupUserPromote: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TGroupUsersPromote.protoMessageName + ".GroupUserPromote"

    var groupID: String = String()

    var userID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.groupID)
        case 2: try decoder.decodeSingularStringField(value: &self.userID)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.groupID.isEmpty {
        try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
      }
      if !self.userID.isEmpty {
        try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.groupUsers)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupUsers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupUsers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TopicId is the core domain type representing a chat topic identifier.
struct Server_TopicId: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TopicId"

  var id: Server_TopicId.OneOf_ID? = nil

  var dm: String {
    get {
      if case .dm(let v)? = id {return v}
      return String()
    }
    set {id = .dm(newValue)}
  }

  var room: String {
    get {
      if case .room(let v)? = id {return v}
      return String()
    }
    set {id = .room(newValue)}
  }

  var groupID: String {
    get {
      if case .groupID(let v)? = id {return v}
      return String()
    }
    set {id = .groupID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case dm(String)
    case room(String)
    case groupID(String)

    static func ==(lhs: Server_TopicId.OneOf_ID, rhs: Server_TopicId.OneOf_ID) -> Bool {
      switch (lhs, rhs) {
      case (.dm(let l), .dm(let r)): return l == r
      case (.room(let l), .room(let r)): return l == r
      case (.groupID(let l), .groupID(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .dm(v)}
      case 2:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .room(v)}
      case 3:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .groupID(v)}
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.id {
    case .dm(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .room(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .groupID(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// UserPresence is the core domain type representing a presense in chat topic.
/// A user can have multiple presences
struct Server_UserPresence: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".UserPresence"

  //// User ID
  var userID: String = String()

  //// Session ID
  var sessionID: String = String()

  //// User handle
  var handle: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.userID)
      case 2: try decoder.decodeSingularStringField(value: &self.sessionID)
      case 3: try decoder.decodeSingularStringField(value: &self.handle)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if !self.handle.isEmpty {
      try visitor.visitSingularStringField(value: self.handle, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TTopicsJoin adds the current user's session to a chat topic.
///
/// @returns TTopics
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TTopicsJoin: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TTopicsJoin"

  var joins: [Server_TTopicsJoin.TopicJoin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TopicJoin: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TTopicsJoin.protoMessageName + ".TopicJoin"

    var id: Server_TTopicsJoin.TopicJoin.OneOf_ID? = nil

    var userID: String {
      get {
        if case .userID(let v)? = id {return v}
        return String()
      }
      set {id = .userID(newValue)}
    }

    var room: String {
      get {
        if case .room(let v)? = id {return v}
        return String()
      }
      set {id = .room(newValue)}
    }

    var groupID: String {
      get {
        if case .groupID(let v)? = id {return v}
        return String()
      }
      set {id = .groupID(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ID: Equatable {
      case userID(String)
      case room(String)
      case groupID(String)

      static func ==(lhs: Server_TTopicsJoin.TopicJoin.OneOf_ID, rhs: Server_TTopicsJoin.TopicJoin.OneOf_ID) -> Bool {
        switch (lhs, rhs) {
        case (.userID(let l), .userID(let r)): return l == r
        case (.room(let l), .room(let r)): return l == r
        case (.groupID(let l), .groupID(let r)): return l == r
        default: return false
        }
      }
    }

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .userID(v)}
        case 2:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .room(v)}
        case 3:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .groupID(v)}
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      switch self.id {
      case .userID(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .room(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .groupID(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      case nil: break
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.joins)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.joins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.joins, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// List of new topics that the session has joined.
struct Server_TTopics: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TTopics"

  var topics: [Server_TTopics.Topic] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Topic: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TTopics.protoMessageName + ".Topic"

    //// Chat topics
    var topic: Server_TopicId {
      get {return _storage._topic ?? Server_TopicId()}
      set {_uniqueStorage()._topic = newValue}
    }
    /// Returns true if `topic` has been explicitly set.
    var hasTopic: Bool {return _storage._topic != nil}
    /// Clears the value of `topic`. Subsequent reads from it will return its default value.
    mutating func clearTopic() {_storage._topic = nil}

    //// List of chat presences in the topic
    var presences: [Server_UserPresence] {
      get {return _storage._presences}
      set {_uniqueStorage()._presences = newValue}
    }

    //// Current user's chat presence
    var self_p: Server_UserPresence {
      get {return _storage._self_p ?? Server_UserPresence()}
      set {_uniqueStorage()._self_p = newValue}
    }
    /// Returns true if `self_p` has been explicitly set.
    var hasSelf_p: Bool {return _storage._self_p != nil}
    /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
    mutating func clearSelf_p() {_storage._self_p = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularMessageField(value: &_storage._topic)
          case 2: try decoder.decodeRepeatedMessageField(value: &_storage._presences)
          case 3: try decoder.decodeSingularMessageField(value: &_storage._self_p)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if let v = _storage._topic {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !_storage._presences.isEmpty {
          try visitor.visitRepeatedMessageField(value: _storage._presences, fieldNumber: 2)
        }
        if let v = _storage._self_p {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.topics)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TTopicsLeave removes the current user's session from the chat topic.
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TTopicsLeave: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TTopicsLeave"

  var topics: [Server_TopicId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.topics)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TTopicMessageSend sends a message to the topic
struct Server_TTopicMessageSend: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TTopicMessageSend"

  var topic: Server_TopicId {
    get {return _storage._topic ?? Server_TopicId()}
    set {_uniqueStorage()._topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  var hasTopic: Bool {return _storage._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  mutating func clearTopic() {_storage._topic = nil}

  var data: String {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._topic)
        case 2: try decoder.decodeSingularStringField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._topic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._data.isEmpty {
        try visitor.visitSingularStringField(value: _storage._data, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TTopicMessageAck sends an ack message to the topic
struct Server_TTopicMessageAck: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TTopicMessageAck"

  var messageID: String = String()

  var createdAt: Int64 = 0

  var expiresAt: Int64 = 0

  var handle: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.messageID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.createdAt)
      case 3: try decoder.decodeSingularInt64Field(value: &self.expiresAt)
      case 4: try decoder.decodeSingularStringField(value: &self.handle)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularInt64Field(value: self.createdAt, fieldNumber: 2)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularInt64Field(value: self.expiresAt, fieldNumber: 3)
    }
    if !self.handle.isEmpty {
      try visitor.visitSingularStringField(value: self.handle, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TopicMessage is the core domain type representing a chat message that is sent by another user.
struct Server_TopicMessage: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TopicMessage"

  var topic: Server_TopicId {
    get {return _storage._topic ?? Server_TopicId()}
    set {_uniqueStorage()._topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  var hasTopic: Bool {return _storage._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  mutating func clearTopic() {_storage._topic = nil}

  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  var messageID: String {
    get {return _storage._messageID}
    set {_uniqueStorage()._messageID = newValue}
  }

  var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  var expiresAt: Int64 {
    get {return _storage._expiresAt}
    set {_uniqueStorage()._expiresAt = newValue}
  }

  var handle: String {
    get {return _storage._handle}
    set {_uniqueStorage()._handle = newValue}
  }

  //// The chat message types are:
  //// Chat message (0) - Chat messages sent by users
  //// Group Join (1) - Notification - a user joined the group - send by the system
  //// Group Add (2) - Notification - a user was added/accepted to the group - send by the system
  //// Group Leave (3) - Notification - a user left the group - send by the system
  //// Group Kick (4) - Notification - a user was kicked from the group - send by the system
  //// Group Promoted (5) - Notification - a user was promoted to group admin - send by the system
  var type: Int64 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var data: String {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._topic)
        case 2: try decoder.decodeSingularStringField(value: &_storage._userID)
        case 3: try decoder.decodeSingularStringField(value: &_storage._messageID)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._createdAt)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._expiresAt)
        case 6: try decoder.decodeSingularStringField(value: &_storage._handle)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._type)
        case 8: try decoder.decodeSingularStringField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._topic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
      if !_storage._messageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._messageID, fieldNumber: 3)
      }
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 4)
      }
      if _storage._expiresAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expiresAt, fieldNumber: 5)
      }
      if !_storage._handle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._handle, fieldNumber: 6)
      }
      if _storage._type != 0 {
        try visitor.visitSingularInt64Field(value: _storage._type, fieldNumber: 7)
      }
      if !_storage._data.isEmpty {
        try visitor.visitSingularStringField(value: _storage._data, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TTopicMessagesList retrieves a list of historic messages for a topic.
///
/// @returns TTopicMessages
struct Server_TTopicMessagesList: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TTopicMessagesList"

  var id: Server_TTopicMessagesList.OneOf_ID? = nil

  var userID: String {
    get {
      if case .userID(let v)? = id {return v}
      return String()
    }
    set {id = .userID(newValue)}
  }

  var room: String {
    get {
      if case .room(let v)? = id {return v}
      return String()
    }
    set {id = .room(newValue)}
  }

  var groupID: String {
    get {
      if case .groupID(let v)? = id {return v}
      return String()
    }
    set {id = .groupID(newValue)}
  }

  //// Use the cursor to paginate through more message.
  //// The value of this comes from TTopicMessages.cursor.
  var cursor: String = String()

  var forward: Bool = false

  var limit: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case userID(String)
    case room(String)
    case groupID(String)

    static func ==(lhs: Server_TTopicMessagesList.OneOf_ID, rhs: Server_TTopicMessagesList.OneOf_ID) -> Bool {
      switch (lhs, rhs) {
      case (.userID(let l), .userID(let r)): return l == r
      case (.room(let l), .room(let r)): return l == r
      case (.groupID(let l), .groupID(let r)): return l == r
      default: return false
      }
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .userID(v)}
      case 2:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .room(v)}
      case 3:
        if self.id != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.id = .groupID(v)}
      case 4: try decoder.decodeSingularStringField(value: &self.cursor)
      case 5: try decoder.decodeSingularBoolField(value: &self.forward)
      case 6: try decoder.decodeSingularInt64Field(value: &self.limit)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.id {
    case .userID(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .room(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .groupID(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case nil: break
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 4)
    }
    if self.forward != false {
      try visitor.visitSingularBoolField(value: self.forward, fieldNumber: 5)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TTopicMessages is a list of historic messages for a topic.
struct Server_TTopicMessages: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TTopicMessages"

  var messages: [Server_TopicMessage] = []

  var cursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      case 2: try decoder.decodeSingularStringField(value: &self.cursor)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TopicPresence is the core domain type representing a change presences for a topic.
struct Server_TopicPresence: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TopicPresence"

  var topic: Server_TopicId {
    get {return _storage._topic ?? Server_TopicId()}
    set {_uniqueStorage()._topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  var hasTopic: Bool {return _storage._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  mutating func clearTopic() {_storage._topic = nil}

  var joins: [Server_UserPresence] {
    get {return _storage._joins}
    set {_uniqueStorage()._joins = newValue}
  }

  var leaves: [Server_UserPresence] {
    get {return _storage._leaves}
    set {_uniqueStorage()._leaves = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._topic)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._joins)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._leaves)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._topic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._joins.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._joins, fieldNumber: 2)
      }
      if !_storage._leaves.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._leaves, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// PropertyPair is a core domain type respresenting a single user property
struct Server_PropertyPair: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".PropertyPair"

  var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var stringSet: Server_PropertyPair.StringSet {
    get {
      if case .stringSet(let v)? = _storage._value {return v}
      return Server_PropertyPair.StringSet()
    }
    set {_uniqueStorage()._value = .stringSet(newValue)}
  }

  var boolValue: Bool {
    get {
      if case .boolValue(let v)? = _storage._value {return v}
      return false
    }
    set {_uniqueStorage()._value = .boolValue(newValue)}
  }

  var intValue: Int64 {
    get {
      if case .intValue(let v)? = _storage._value {return v}
      return 0
    }
    set {_uniqueStorage()._value = .intValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case stringSet(Server_PropertyPair.StringSet)
    case boolValue(Bool)
    case intValue(Int64)

    static func ==(lhs: Server_PropertyPair.OneOf_Value, rhs: Server_PropertyPair.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.stringSet(let l), .stringSet(let r)): return l == r
      case (.boolValue(let l), .boolValue(let r)): return l == r
      case (.intValue(let l), .intValue(let r)): return l == r
      default: return false
      }
    }
  }

  //// Set of string user property
  struct StringSet: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_PropertyPair.protoMessageName + ".StringSet"

    var values: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &self.values)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.values.isEmpty {
        try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._key)
        case 2:
          var v: Server_PropertyPair.StringSet?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .stringSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .stringSet(v)}
        case 3:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._value = .boolValue(v)}
        case 4:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {_storage._value = .intValue(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 1)
      }
      switch _storage._value {
      case .stringSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .boolValue(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      case .intValue(let v)?:
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// MatchmakeFilter is a core domain type respresenting a filter to use for matchmaking.
struct Server_MatchmakeFilter: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".MatchmakeFilter"

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var term: Server_MatchmakeFilter.TermFilter {
    get {
      if case .term(let v)? = _storage._value {return v}
      return Server_MatchmakeFilter.TermFilter()
    }
    set {_uniqueStorage()._value = .term(newValue)}
  }

  var range: Server_MatchmakeFilter.RangeFilter {
    get {
      if case .range(let v)? = _storage._value {return v}
      return Server_MatchmakeFilter.RangeFilter()
    }
    set {_uniqueStorage()._value = .range(newValue)}
  }

  var check: Bool {
    get {
      if case .check(let v)? = _storage._value {return v}
      return false
    }
    set {_uniqueStorage()._value = .check(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case term(Server_MatchmakeFilter.TermFilter)
    case range(Server_MatchmakeFilter.RangeFilter)
    case check(Bool)

    static func ==(lhs: Server_MatchmakeFilter.OneOf_Value, rhs: Server_MatchmakeFilter.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.term(let l), .term(let r)): return l == r
      case (.range(let l), .range(let r)): return l == r
      case (.check(let l), .check(let r)): return l == r
      default: return false
      }
    }
  }

  //// String term filters
  struct TermFilter: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_MatchmakeFilter.protoMessageName + ".TermFilter"

    var terms: [String] = []

    var matchAllTerms: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &self.terms)
        case 2: try decoder.decodeSingularBoolField(value: &self.matchAllTerms)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.terms.isEmpty {
        try visitor.visitRepeatedStringField(value: self.terms, fieldNumber: 1)
      }
      if self.matchAllTerms != false {
        try visitor.visitSingularBoolField(value: self.matchAllTerms, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  //// Numeric range filter
  struct RangeFilter: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_MatchmakeFilter.protoMessageName + ".RangeFilter"

    /// inclusive lower_bound
    var lowerBound: Int64 = 0

    /// inclusive upper_bound
    var upperBound: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &self.lowerBound)
        case 2: try decoder.decodeSingularInt64Field(value: &self.upperBound)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if self.lowerBound != 0 {
        try visitor.visitSingularInt64Field(value: self.lowerBound, fieldNumber: 1)
      }
      if self.upperBound != 0 {
        try visitor.visitSingularInt64Field(value: self.upperBound, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2:
          var v: Server_MatchmakeFilter.TermFilter?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .term(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .term(v)}
        case 3:
          var v: Server_MatchmakeFilter.RangeFilter?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .range(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .range(v)}
        case 4:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._value = .check(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      switch _storage._value {
      case .term(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .range(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .check(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TMatchmakeAdd is used to add the current user to the matchmaking pool.
///
/// @returns TMatchmakeTicket
struct Server_TMatchmakeAdd: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TMatchmakeAdd"

  //// Match user with other users looking for a match with the the following number of users.
  var requiredCount: Int64 = 0

  //// List of filters that need to match.
  var filters: [Server_MatchmakeFilter] = []

  //// List of properties for the current user.
  var properties: [Server_PropertyPair] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.requiredCount)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.filters)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.properties)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requiredCount != 0 {
      try visitor.visitSingularInt64Field(value: self.requiredCount, fieldNumber: 1)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 2)
    }
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TMatchmakeTicket represents a matchmake ticket. Use the ticket to cancel matchmaking search.
struct Server_TMatchmakeTicket: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TMatchmakeTicket"

  var ticket: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.ticket)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ticket.isEmpty {
      try visitor.visitSingularStringField(value: self.ticket, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TMatchmakeRemove is used to cancel a matchmake search.
struct Server_TMatchmakeRemove: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TMatchmakeRemove"

  var ticket: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.ticket)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ticket.isEmpty {
      try visitor.visitSingularStringField(value: self.ticket, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// MatchmakeMatched is the core domain type representing a found match via matchmaking.
struct Server_MatchmakeMatched: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".MatchmakeMatched"

  //// Matchmaking ticket. Use this to invalidate ticket cache on the client.
  var ticket: String {
    get {return _storage._ticket}
    set {_uniqueStorage()._ticket = newValue}
  }

  //// Matchmaking token. Use this to accept the match. This is a onetime token which is only valid for a limited time.
  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  var presences: [Server_UserPresence] {
    get {return _storage._presences}
    set {_uniqueStorage()._presences = newValue}
  }

  var self_p: Server_UserPresence {
    get {return _storage._self_p ?? Server_UserPresence()}
    set {_uniqueStorage()._self_p = newValue}
  }
  /// Returns true if `self_p` has been explicitly set.
  var hasSelf_p: Bool {return _storage._self_p != nil}
  /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
  mutating func clearSelf_p() {_storage._self_p = nil}

  var properties: [Server_MatchmakeMatched.UserProperty] {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  //// Matched user presence and properties
  struct UserProperty: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_MatchmakeMatched.protoMessageName + ".UserProperty"

    var userID: String = String()

    var properties: [Server_PropertyPair] = []

    var filters: [Server_MatchmakeFilter] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.userID)
        case 2: try decoder.decodeRepeatedMessageField(value: &self.properties)
        case 3: try decoder.decodeRepeatedMessageField(value: &self.filters)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.userID.isEmpty {
        try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
      }
      if !self.properties.isEmpty {
        try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 2)
      }
      if !self.filters.isEmpty {
        try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._ticket)
        case 2: try decoder.decodeSingularStringField(value: &_storage._token)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._presences)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._self_p)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._properties)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._ticket.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ticket, fieldNumber: 1)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 2)
      }
      if !_storage._presences.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._presences, fieldNumber: 3)
      }
      if let v = _storage._self_p {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._properties.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._properties, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Match is the core domain type representing an on-going match.
struct Server_Match: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Match"

  var matchID: String {
    get {return _storage._matchID}
    set {_uniqueStorage()._matchID = newValue}
  }

  var presences: [Server_UserPresence] {
    get {return _storage._presences}
    set {_uniqueStorage()._presences = newValue}
  }

  var self_p: Server_UserPresence {
    get {return _storage._self_p ?? Server_UserPresence()}
    set {_uniqueStorage()._self_p = newValue}
  }
  /// Returns true if `self_p` has been explicitly set.
  var hasSelf_p: Bool {return _storage._self_p != nil}
  /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
  mutating func clearSelf_p() {_storage._self_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._matchID)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._presences)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._self_p)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._matchID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._matchID, fieldNumber: 1)
      }
      if !_storage._presences.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._presences, fieldNumber: 2)
      }
      if let v = _storage._self_p {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// MatchPresence is the core domain type representing the users participating and leaving a match.
struct Server_MatchPresence: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".MatchPresence"

  var matchID: String = String()

  var joins: [Server_UserPresence] = []

  var leaves: [Server_UserPresence] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.matchID)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.joins)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.leaves)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchID.isEmpty {
      try visitor.visitSingularStringField(value: self.matchID, fieldNumber: 1)
    }
    if !self.joins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.joins, fieldNumber: 2)
    }
    if !self.leaves.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leaves, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TMatchCreate is used to create a new match from scratch. Use TMatchesJoin to make other users join the match.
///
/// @returns TMatch
struct Server_TMatchCreate: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TMatchCreate"

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TMatch contains a match object.
struct Server_TMatch: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TMatch"

  var match: Server_Match {
    get {return _storage._match ?? Server_Match()}
    set {_uniqueStorage()._match = newValue}
  }
  /// Returns true if `match` has been explicitly set.
  var hasMatch: Bool {return _storage._match != nil}
  /// Clears the value of `match`. Subsequent reads from it will return its default value.
  mutating func clearMatch() {_storage._match = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._match)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._match {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TMatchesJoin is used to join existing matches.
///
/// @returns TMatches
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TMatchesJoin: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TMatchesJoin"

  var matches: [Server_TMatchesJoin.MatchJoin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct MatchJoin: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TMatchesJoin.protoMessageName + ".MatchJoin"

    var id: Server_TMatchesJoin.MatchJoin.OneOf_ID? = nil

    var matchID: String {
      get {
        if case .matchID(let v)? = id {return v}
        return String()
      }
      set {id = .matchID(newValue)}
    }

    var token: String {
      get {
        if case .token(let v)? = id {return v}
        return String()
      }
      set {id = .token(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ID: Equatable {
      case matchID(String)
      case token(String)

      static func ==(lhs: Server_TMatchesJoin.MatchJoin.OneOf_ID, rhs: Server_TMatchesJoin.MatchJoin.OneOf_ID) -> Bool {
        switch (lhs, rhs) {
        case (.matchID(let l), .matchID(let r)): return l == r
        case (.token(let l), .token(let r)): return l == r
        default: return false
        }
      }
    }

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .matchID(v)}
        case 2:
          if self.id != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {self.id = .token(v)}
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      switch self.id {
      case .matchID(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .token(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case nil: break
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.matches)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TMatch contains a list of matches.
struct Server_TMatches: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TMatches"

  var matches: [Server_Match] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.matches)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// MatchDataSend is used to send match data to the server.
struct Server_MatchDataSend: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".MatchDataSend"

  var matchID: String = String()

  //// Custom Op code to make disguishing different message types easier.
  var opCode: Int64 = 0

  var data: Data = SwiftProtobuf.Internal.emptyData

  var presences: [Server_UserPresence] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.matchID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.opCode)
      case 3: try decoder.decodeSingularBytesField(value: &self.data)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.presences)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchID.isEmpty {
      try visitor.visitSingularStringField(value: self.matchID, fieldNumber: 1)
    }
    if self.opCode != 0 {
      try visitor.visitSingularInt64Field(value: self.opCode, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if !self.presences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.presences, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// MatchData is the core domain type representing a match data.
struct Server_MatchData: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".MatchData"

  var matchID: String {
    get {return _storage._matchID}
    set {_uniqueStorage()._matchID = newValue}
  }

  var presence: Server_UserPresence {
    get {return _storage._presence ?? Server_UserPresence()}
    set {_uniqueStorage()._presence = newValue}
  }
  /// Returns true if `presence` has been explicitly set.
  var hasPresence: Bool {return _storage._presence != nil}
  /// Clears the value of `presence`. Subsequent reads from it will return its default value.
  mutating func clearPresence() {_storage._presence = nil}

  var opCode: Int64 {
    get {return _storage._opCode}
    set {_uniqueStorage()._opCode = newValue}
  }

  var data: Data {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._matchID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._presence)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._opCode)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._matchID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._matchID, fieldNumber: 1)
      }
      if let v = _storage._presence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._opCode != 0 {
        try visitor.visitSingularInt64Field(value: _storage._opCode, fieldNumber: 3)
      }
      if !_storage._data.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._data, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TMatchesLeave is used to leave an existing matches.
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TMatchesLeave: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TMatchesLeave"

  var matchIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.matchIds)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.matchIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TStorageList is used to list records from Storage
///
/// @returns TStorageData
struct Server_TStorageList: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TStorageList"

  var userID: String = String()

  var bucket: String = String()

  var collection: String = String()

  var limit: Int64 = 0

  var cursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.userID)
      case 2: try decoder.decodeSingularStringField(value: &self.bucket)
      case 3: try decoder.decodeSingularStringField(value: &self.collection)
      case 4: try decoder.decodeSingularInt64Field(value: &self.limit)
      case 5: try decoder.decodeSingularStringField(value: &self.cursor)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 2)
    }
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 3)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 4)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TStorageFetch is used to retrieve a list of records from Storage
///
/// @returns TStorageData
struct Server_TStorageFetch: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TStorageFetch"

  var keys: [Server_TStorageFetch.StorageKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StorageKey: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TStorageFetch.protoMessageName + ".StorageKey"

    var bucket: String = String()

    var collection: String = String()

    var record: String = String()

    var userID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.bucket)
        case 2: try decoder.decodeSingularStringField(value: &self.collection)
        case 3: try decoder.decodeSingularStringField(value: &self.record)
        case 4: try decoder.decodeSingularStringField(value: &self.userID)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.bucket.isEmpty {
        try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
      }
      if !self.collection.isEmpty {
        try visitor.visitSingularStringField(value: self.collection, fieldNumber: 2)
      }
      if !self.record.isEmpty {
        try visitor.visitSingularStringField(value: self.record, fieldNumber: 3)
      }
      if !self.userID.isEmpty {
        try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TStorageData contains a list of Storage data records.
struct Server_TStorageData: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TStorageData"

  var data: [Server_TStorageData.StorageData] = []

  var cursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StorageData: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TStorageData.protoMessageName + ".StorageData"

    var bucket: String = String()

    var collection: String = String()

    var record: String = String()

    var userID: String = String()

    var value: String = String()

    var version: String = String()

    var permissionRead: Int32 = 0

    var permissionWrite: Int32 = 0

    var createdAt: Int64 = 0

    var updatedAt: Int64 = 0

    var expiresAt: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.bucket)
        case 2: try decoder.decodeSingularStringField(value: &self.collection)
        case 3: try decoder.decodeSingularStringField(value: &self.record)
        case 4: try decoder.decodeSingularStringField(value: &self.userID)
        case 5: try decoder.decodeSingularStringField(value: &self.value)
        case 6: try decoder.decodeSingularStringField(value: &self.version)
        case 7: try decoder.decodeSingularInt32Field(value: &self.permissionRead)
        case 8: try decoder.decodeSingularInt32Field(value: &self.permissionWrite)
        case 9: try decoder.decodeSingularInt64Field(value: &self.createdAt)
        case 10: try decoder.decodeSingularInt64Field(value: &self.updatedAt)
        case 11: try decoder.decodeSingularInt64Field(value: &self.expiresAt)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.bucket.isEmpty {
        try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
      }
      if !self.collection.isEmpty {
        try visitor.visitSingularStringField(value: self.collection, fieldNumber: 2)
      }
      if !self.record.isEmpty {
        try visitor.visitSingularStringField(value: self.record, fieldNumber: 3)
      }
      if !self.userID.isEmpty {
        try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
      }
      if !self.value.isEmpty {
        try visitor.visitSingularStringField(value: self.value, fieldNumber: 5)
      }
      if !self.version.isEmpty {
        try visitor.visitSingularStringField(value: self.version, fieldNumber: 6)
      }
      if self.permissionRead != 0 {
        try visitor.visitSingularInt32Field(value: self.permissionRead, fieldNumber: 7)
      }
      if self.permissionWrite != 0 {
        try visitor.visitSingularInt32Field(value: self.permissionWrite, fieldNumber: 8)
      }
      if self.createdAt != 0 {
        try visitor.visitSingularInt64Field(value: self.createdAt, fieldNumber: 9)
      }
      if self.updatedAt != 0 {
        try visitor.visitSingularInt64Field(value: self.updatedAt, fieldNumber: 10)
      }
      if self.expiresAt != 0 {
        try visitor.visitSingularInt64Field(value: self.expiresAt, fieldNumber: 11)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.data)
      case 2: try decoder.decodeSingularStringField(value: &self.cursor)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TStorageWrite is used to store a list of records to Storage.
///
/// The server provides transactional gurantuees. If one record fails to be inserted,
/// the entire operation is rolled backed and marked as an error.
///
/// @returns TStorageKey
struct Server_TStorageWrite: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TStorageWrite"

  var data: [Server_TStorageWrite.StorageData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StorageData: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TStorageWrite.protoMessageName + ".StorageData"

    var bucket: String = String()

    var collection: String = String()

    var record: String = String()

    var value: String = String()

    /// if-match and if-none-match
    var version: String = String()

    var permissionRead: Int32 = 0

    var permissionWrite: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.bucket)
        case 2: try decoder.decodeSingularStringField(value: &self.collection)
        case 3: try decoder.decodeSingularStringField(value: &self.record)
        case 4: try decoder.decodeSingularStringField(value: &self.value)
        case 5: try decoder.decodeSingularStringField(value: &self.version)
        case 6: try decoder.decodeSingularInt32Field(value: &self.permissionRead)
        case 7: try decoder.decodeSingularInt32Field(value: &self.permissionWrite)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.bucket.isEmpty {
        try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
      }
      if !self.collection.isEmpty {
        try visitor.visitSingularStringField(value: self.collection, fieldNumber: 2)
      }
      if !self.record.isEmpty {
        try visitor.visitSingularStringField(value: self.record, fieldNumber: 3)
      }
      if !self.value.isEmpty {
        try visitor.visitSingularStringField(value: self.value, fieldNumber: 4)
      }
      if !self.version.isEmpty {
        try visitor.visitSingularStringField(value: self.version, fieldNumber: 5)
      }
      if self.permissionRead != 0 {
        try visitor.visitSingularInt32Field(value: self.permissionRead, fieldNumber: 6)
      }
      if self.permissionWrite != 0 {
        try visitor.visitSingularInt32Field(value: self.permissionWrite, fieldNumber: 7)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3: try decoder.decodeRepeatedMessageField(value: &self.data)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TStorageUpdate is used to update a list of records in Storage.
///
/// The server provides transactional gurantuees. If one record fails to be updated,
/// the entire operation is rolled backed and marked as an error.
///
/// @returns TStorageKey
struct Server_TStorageUpdate: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TStorageUpdate"

  var updates: [Server_TStorageUpdate.StorageUpdate] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StorageUpdate: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TStorageUpdate.protoMessageName + ".StorageUpdate"

    var key: Server_TStorageUpdate.StorageUpdate.StorageKey {
      get {return _storage._key ?? Server_TStorageUpdate.StorageUpdate.StorageKey()}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {_storage._key = nil}

    var permissionRead: Int32 {
      get {return _storage._permissionRead}
      set {_uniqueStorage()._permissionRead = newValue}
    }

    var permissionWrite: Int32 {
      get {return _storage._permissionWrite}
      set {_uniqueStorage()._permissionWrite = newValue}
    }

    var ops: [Server_TStorageUpdate.StorageUpdate.UpdateOp] {
      get {return _storage._ops}
      set {_uniqueStorage()._ops = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct UpdateOp: SwiftProtobuf.Message {
      static let protoMessageName: String = Server_TStorageUpdate.StorageUpdate.protoMessageName + ".UpdateOp"

      //// Update op code - must be one of the UpdateOpCode enums above.
      var op: Int32 = 0

      var path: String = String()

      var value: String = String()

      var from: String = String()

      var conditional: Bool = false

      var assert: Int64 = 0

      var ops: [Server_TStorageUpdate.StorageUpdate.UpdateOp] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum UpdateOpCode: SwiftProtobuf.Enum {
        typealias RawValue = Int

        //// Add field or value to array at the path.
        case add // = 0

        //// Append a value or array of values at the path.
        case append // = 1

        //// Copy value at the path to another path.
        case copy // = 2

        //// Add a positive/negative value to the value at the path.
        case incr // = 3

        //// Initialize the value at the path ONLY if its not already present.
        case init_ // = 4

        //// Perform a merge of the object at the path.
        case merge // = 5

        //// Move a value from one path to another and remove from the original path.
        case move // = 6

        //// Perform a JSON patch with the sequence of operations on the subpath specified
        case patch // = 7

        //// Remove the value or array at the path.
        case remove // = 8

        //// Replaces an existing value at the specified path.
        case replace // = 9

        //// Tests equality of the value at the path. The entire patch set fails if the test fails.
        case test // = 10

        //// Performs a comparator which returns -1, 0, or 1 depending on whether the value is less than, the same, or greater than the value in the path.
        case compare // = 11
        case UNRECOGNIZED(Int)

        init() {
          self = .add
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .add
          case 1: self = .append
          case 2: self = .copy
          case 3: self = .incr
          case 4: self = .init_
          case 5: self = .merge
          case 6: self = .move
          case 7: self = .patch
          case 8: self = .remove
          case 9: self = .replace
          case 10: self = .test
          case 11: self = .compare
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .add: return 0
          case .append: return 1
          case .copy: return 2
          case .incr: return 3
          case .init_: return 4
          case .merge: return 5
          case .move: return 6
          case .patch: return 7
          case .remove: return 8
          case .replace: return 9
          case .test: return 10
          case .compare: return 11
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}

      /// Used by the decoding initializers in the SwiftProtobuf library, not generally
      /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
      /// initializers are defined in the SwiftProtobuf library. See the Message and
      /// Message+*Additions` files.
      mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularInt32Field(value: &self.op)
          case 2: try decoder.decodeSingularStringField(value: &self.path)
          case 3: try decoder.decodeSingularStringField(value: &self.value)
          case 4: try decoder.decodeSingularStringField(value: &self.from)
          case 5: try decoder.decodeSingularBoolField(value: &self.conditional)
          case 6: try decoder.decodeSingularInt64Field(value: &self.assert)
          case 7: try decoder.decodeRepeatedMessageField(value: &self.ops)
          default: break
          }
        }
      }

      /// Used by the encoding methods of the SwiftProtobuf library, not generally
      /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
      /// other serializer methods are defined in the SwiftProtobuf library. See the
      /// `Message` and `Message+*Additions` files.
      func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.op != 0 {
          try visitor.visitSingularInt32Field(value: self.op, fieldNumber: 1)
        }
        if !self.path.isEmpty {
          try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
        }
        if !self.value.isEmpty {
          try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
        }
        if !self.from.isEmpty {
          try visitor.visitSingularStringField(value: self.from, fieldNumber: 4)
        }
        if self.conditional != false {
          try visitor.visitSingularBoolField(value: self.conditional, fieldNumber: 5)
        }
        if self.assert != 0 {
          try visitor.visitSingularInt64Field(value: self.assert, fieldNumber: 6)
        }
        if !self.ops.isEmpty {
          try visitor.visitRepeatedMessageField(value: self.ops, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
      }
    }

    struct StorageKey: SwiftProtobuf.Message {
      static let protoMessageName: String = Server_TStorageUpdate.StorageUpdate.protoMessageName + ".StorageKey"

      var bucket: String = String()

      var collection: String = String()

      var record: String = String()

      /// if-match and if-none-match
      var version: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      /// Used by the decoding initializers in the SwiftProtobuf library, not generally
      /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
      /// initializers are defined in the SwiftProtobuf library. See the Message and
      /// Message+*Additions` files.
      mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularStringField(value: &self.bucket)
          case 2: try decoder.decodeSingularStringField(value: &self.collection)
          case 3: try decoder.decodeSingularStringField(value: &self.record)
          case 4: try decoder.decodeSingularStringField(value: &self.version)
          default: break
          }
        }
      }

      /// Used by the encoding methods of the SwiftProtobuf library, not generally
      /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
      /// other serializer methods are defined in the SwiftProtobuf library. See the
      /// `Message` and `Message+*Additions` files.
      func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.bucket.isEmpty {
          try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
        }
        if !self.collection.isEmpty {
          try visitor.visitSingularStringField(value: self.collection, fieldNumber: 2)
        }
        if !self.record.isEmpty {
          try visitor.visitSingularStringField(value: self.record, fieldNumber: 3)
        }
        if !self.version.isEmpty {
          try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
      }
    }

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
          case 2: try decoder.decodeSingularInt32Field(value: &_storage._permissionRead)
          case 3: try decoder.decodeSingularInt32Field(value: &_storage._permissionWrite)
          case 4: try decoder.decodeRepeatedMessageField(value: &_storage._ops)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if let v = _storage._key {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if _storage._permissionRead != 0 {
          try visitor.visitSingularInt32Field(value: _storage._permissionRead, fieldNumber: 2)
        }
        if _storage._permissionWrite != 0 {
          try visitor.visitSingularInt32Field(value: _storage._permissionWrite, fieldNumber: 3)
        }
        if !_storage._ops.isEmpty {
          try visitor.visitRepeatedMessageField(value: _storage._ops, fieldNumber: 4)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.updates)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TStorageKey contains a list of Storage keys for the newly stored data.
struct Server_TStorageKeys: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TStorageKeys"

  var keys: [Server_TStorageKeys.StorageKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StorageKey: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TStorageKeys.protoMessageName + ".StorageKey"

    var bucket: String = String()

    var collection: String = String()

    var record: String = String()

    var version: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.bucket)
        case 2: try decoder.decodeSingularStringField(value: &self.collection)
        case 3: try decoder.decodeSingularStringField(value: &self.record)
        case 4: try decoder.decodeSingularStringField(value: &self.version)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.bucket.isEmpty {
        try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
      }
      if !self.collection.isEmpty {
        try visitor.visitSingularStringField(value: self.collection, fieldNumber: 2)
      }
      if !self.record.isEmpty {
        try visitor.visitSingularStringField(value: self.record, fieldNumber: 3)
      }
      if !self.version.isEmpty {
        try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TStorageRemove is used to remove a list of records from Storage.
///
/// The server provides transactional gurantuees. If one record fails to be deleted,
/// the entire operation is rolled backed and marked as an error.
struct Server_TStorageRemove: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TStorageRemove"

  var keys: [Server_TStorageRemove.StorageKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StorageKey: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TStorageRemove.protoMessageName + ".StorageKey"

    var bucket: String = String()

    var collection: String = String()

    var record: String = String()

    var version: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.bucket)
        case 2: try decoder.decodeSingularStringField(value: &self.collection)
        case 3: try decoder.decodeSingularStringField(value: &self.record)
        case 4: try decoder.decodeSingularStringField(value: &self.version)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.bucket.isEmpty {
        try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
      }
      if !self.collection.isEmpty {
        try visitor.visitSingularStringField(value: self.collection, fieldNumber: 2)
      }
      if !self.record.isEmpty {
        try visitor.visitSingularStringField(value: self.record, fieldNumber: 3)
      }
      if !self.version.isEmpty {
        try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Leaderboard is the core domain type representing a Leaderboard setup in the server.
struct Server_Leaderboard: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Leaderboard"

  var id: String = String()

  //// Whether the user can submit records directly via the client or not
  var authoritative: Bool = false

  var sort: Int64 = 0

  var count: Int64 = 0

  var resetSchedule: String = String()

  var metadata: String = String()

  var nextID: String = String()

  var prevID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularBoolField(value: &self.authoritative)
      case 3: try decoder.decodeSingularInt64Field(value: &self.sort)
      case 4: try decoder.decodeSingularInt64Field(value: &self.count)
      case 5: try decoder.decodeSingularStringField(value: &self.resetSchedule)
      case 6: try decoder.decodeSingularStringField(value: &self.metadata)
      case 7: try decoder.decodeSingularStringField(value: &self.nextID)
      case 8: try decoder.decodeSingularStringField(value: &self.prevID)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.authoritative != false {
      try visitor.visitSingularBoolField(value: self.authoritative, fieldNumber: 2)
    }
    if self.sort != 0 {
      try visitor.visitSingularInt64Field(value: self.sort, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 4)
    }
    if !self.resetSchedule.isEmpty {
      try visitor.visitSingularStringField(value: self.resetSchedule, fieldNumber: 5)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 6)
    }
    if !self.nextID.isEmpty {
      try visitor.visitSingularStringField(value: self.nextID, fieldNumber: 7)
    }
    if !self.prevID.isEmpty {
      try visitor.visitSingularStringField(value: self.prevID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// LeaderboardRecord is the core domain type representing a Leaderboard entry.
struct Server_LeaderboardRecord: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".LeaderboardRecord"

  var leaderboardID: String = String()

  var ownerID: String = String()

  var handle: String = String()

  //// Language tag corresponding to the BCP 47 spec.
  var lang: String = String()

  var location: String = String()

  var timezone: String = String()

  var rank: Int64 = 0

  var score: Int64 = 0

  var numScore: Int64 = 0

  var metadata: String = String()

  var rankedAt: Int64 = 0

  var updatedAt: Int64 = 0

  var expiresAt: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.leaderboardID)
      case 2: try decoder.decodeSingularStringField(value: &self.ownerID)
      case 3: try decoder.decodeSingularStringField(value: &self.handle)
      case 4: try decoder.decodeSingularStringField(value: &self.lang)
      case 5: try decoder.decodeSingularStringField(value: &self.location)
      case 6: try decoder.decodeSingularStringField(value: &self.timezone)
      case 7: try decoder.decodeSingularInt64Field(value: &self.rank)
      case 8: try decoder.decodeSingularInt64Field(value: &self.score)
      case 9: try decoder.decodeSingularInt64Field(value: &self.numScore)
      case 10: try decoder.decodeSingularStringField(value: &self.metadata)
      case 11: try decoder.decodeSingularInt64Field(value: &self.rankedAt)
      case 12: try decoder.decodeSingularInt64Field(value: &self.updatedAt)
      case 13: try decoder.decodeSingularInt64Field(value: &self.expiresAt)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaderboardID.isEmpty {
      try visitor.visitSingularStringField(value: self.leaderboardID, fieldNumber: 1)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 2)
    }
    if !self.handle.isEmpty {
      try visitor.visitSingularStringField(value: self.handle, fieldNumber: 3)
    }
    if !self.lang.isEmpty {
      try visitor.visitSingularStringField(value: self.lang, fieldNumber: 4)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 5)
    }
    if !self.timezone.isEmpty {
      try visitor.visitSingularStringField(value: self.timezone, fieldNumber: 6)
    }
    if self.rank != 0 {
      try visitor.visitSingularInt64Field(value: self.rank, fieldNumber: 7)
    }
    if self.score != 0 {
      try visitor.visitSingularInt64Field(value: self.score, fieldNumber: 8)
    }
    if self.numScore != 0 {
      try visitor.visitSingularInt64Field(value: self.numScore, fieldNumber: 9)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 10)
    }
    if self.rankedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.rankedAt, fieldNumber: 11)
    }
    if self.updatedAt != 0 {
      try visitor.visitSingularInt64Field(value: self.updatedAt, fieldNumber: 12)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularInt64Field(value: self.expiresAt, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TLeaderboardsList is used to retrieve a list of leaderboards.
///
/// A list of IDs can be supplied optionally, otherwise all leaderboards are returned.
///
/// @returns TLeaderboards
struct Server_TLeaderboardsList: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TLeaderboardsList"

  var limit: Int64 = 0

  //// Use TLeaderboards.cursor to paginate through results.
  var cursor: String = String()

  var filterLeaderboardID: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.limit)
      case 2: try decoder.decodeSingularStringField(value: &self.cursor)
      case 3: try decoder.decodeRepeatedStringField(value: &self.filterLeaderboardID)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    if !self.filterLeaderboardID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filterLeaderboardID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TLeaderboards contains a list of leaderboards.
struct Server_TLeaderboards: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TLeaderboards"

  var leaderboards: [Server_Leaderboard] = []

  var cursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.leaderboards)
      case 2: try decoder.decodeSingularStringField(value: &self.cursor)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaderboards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leaderboards, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TLeaderboardRecordsWrite is used to write new list of records to a given list of leaderboards.
///
/// @returns TLeaderboardRecords
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TLeaderboardRecordsWrite: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TLeaderboardRecordsWrite"

  var records: [Server_TLeaderboardRecordsWrite.LeaderboardRecordWrite] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct LeaderboardRecordWrite: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TLeaderboardRecordsWrite.protoMessageName + ".LeaderboardRecordWrite"

    var leaderboardID: String = String()

    var op: Server_TLeaderboardRecordsWrite.LeaderboardRecordWrite.OneOf_Op? = nil

    var incr: Int64 {
      get {
        if case .incr(let v)? = op {return v}
        return 0
      }
      set {op = .incr(newValue)}
    }

    var decr: Int64 {
      get {
        if case .decr(let v)? = op {return v}
        return 0
      }
      set {op = .decr(newValue)}
    }

    var set: Int64 {
      get {
        if case .set(let v)? = op {return v}
        return 0
      }
      set {op = .set(newValue)}
    }

    var best: Int64 {
      get {
        if case .best(let v)? = op {return v}
        return 0
      }
      set {op = .best(newValue)}
    }

    var location: String = String()

    var timezone: String = String()

    var metadata: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Op: Equatable {
      case incr(Int64)
      case decr(Int64)
      case set(Int64)
      case best(Int64)

      static func ==(lhs: Server_TLeaderboardRecordsWrite.LeaderboardRecordWrite.OneOf_Op, rhs: Server_TLeaderboardRecordsWrite.LeaderboardRecordWrite.OneOf_Op) -> Bool {
        switch (lhs, rhs) {
        case (.incr(let l), .incr(let r)): return l == r
        case (.decr(let l), .decr(let r)): return l == r
        case (.set(let l), .set(let r)): return l == r
        case (.best(let l), .best(let r)): return l == r
        default: return false
        }
      }
    }

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.leaderboardID)
        case 2:
          if self.op != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {self.op = .incr(v)}
        case 3:
          if self.op != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {self.op = .decr(v)}
        case 4:
          if self.op != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {self.op = .set(v)}
        case 5:
          if self.op != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {self.op = .best(v)}
        case 6: try decoder.decodeSingularStringField(value: &self.location)
        case 7: try decoder.decodeSingularStringField(value: &self.timezone)
        case 8: try decoder.decodeSingularStringField(value: &self.metadata)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.leaderboardID.isEmpty {
        try visitor.visitSingularStringField(value: self.leaderboardID, fieldNumber: 1)
      }
      switch self.op {
      case .incr(let v)?:
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
      case .decr(let v)?:
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
      case .set(let v)?:
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      case .best(let v)?:
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
      case nil: break
      }
      if !self.location.isEmpty {
        try visitor.visitSingularStringField(value: self.location, fieldNumber: 6)
      }
      if !self.timezone.isEmpty {
        try visitor.visitSingularStringField(value: self.timezone, fieldNumber: 7)
      }
      if !self.metadata.isEmpty {
        try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 8)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.records)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TLeaderboardRecordsFetch is used to retrieve a list of records from a given list of leaderboards.
///
/// @returns TLeaderboardRecords
///
/// NOTE: The server only processes the first item of the list, and will ignore and logs a warning message for other items.
struct Server_TLeaderboardRecordsFetch: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TLeaderboardRecordsFetch"

  var leaderboardIds: [String] = []

  var limit: Int64 = 0

  //// Use TLeaderboardRecords.cursor to paginate through results.
  var cursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.leaderboardIds)
      case 2: try decoder.decodeSingularInt64Field(value: &self.limit)
      case 3: try decoder.decodeSingularStringField(value: &self.cursor)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaderboardIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.leaderboardIds, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 2)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TLeaderboardRecordsList is used to retrieve a list of records from a given list of leaderboards with given preset filters.
///
/// @returns TLeaderboardRecords
struct Server_TLeaderboardRecordsList: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TLeaderboardRecordsList"

  var leaderboardID: String {
    get {return _storage._leaderboardID}
    set {_uniqueStorage()._leaderboardID = newValue}
  }

  var filter: OneOf_Filter? {
    get {return _storage._filter}
    set {_uniqueStorage()._filter = newValue}
  }

  //// Filter records by one user ID. This is the same as a "heystack" lookup
  var ownerID: String {
    get {
      if case .ownerID(let v)? = _storage._filter {return v}
      return String()
    }
    set {_uniqueStorage()._filter = .ownerID(newValue)}
  }

  //// Filter records by user IDs
  var ownerIds: Server_TLeaderboardRecordsList.Owners {
    get {
      if case .ownerIds(let v)? = _storage._filter {return v}
      return Server_TLeaderboardRecordsList.Owners()
    }
    set {_uniqueStorage()._filter = .ownerIds(newValue)}
  }

  var lang: String {
    get {
      if case .lang(let v)? = _storage._filter {return v}
      return String()
    }
    set {_uniqueStorage()._filter = .lang(newValue)}
  }

  var location: String {
    get {
      if case .location(let v)? = _storage._filter {return v}
      return String()
    }
    set {_uniqueStorage()._filter = .location(newValue)}
  }

  var timezone: String {
    get {
      if case .timezone(let v)? = _storage._filter {return v}
      return String()
    }
    set {_uniqueStorage()._filter = .timezone(newValue)}
  }

  var limit: Int64 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  var cursor: String {
    get {return _storage._cursor}
    set {_uniqueStorage()._cursor = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Filter: Equatable {
    //// Filter records by one user ID. This is the same as a "heystack" lookup
    case ownerID(String)
    //// Filter records by user IDs
    case ownerIds(Server_TLeaderboardRecordsList.Owners)
    case lang(String)
    case location(String)
    case timezone(String)

    static func ==(lhs: Server_TLeaderboardRecordsList.OneOf_Filter, rhs: Server_TLeaderboardRecordsList.OneOf_Filter) -> Bool {
      switch (lhs, rhs) {
      case (.ownerID(let l), .ownerID(let r)): return l == r
      case (.ownerIds(let l), .ownerIds(let r)): return l == r
      case (.lang(let l), .lang(let r)): return l == r
      case (.location(let l), .location(let r)): return l == r
      case (.timezone(let l), .timezone(let r)): return l == r
      default: return false
      }
    }
  }

  struct Owners: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TLeaderboardRecordsList.protoMessageName + ".Owners"

    var ownerIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &self.ownerIds)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.ownerIds.isEmpty {
        try visitor.visitRepeatedStringField(value: self.ownerIds, fieldNumber: 1)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._leaderboardID)
        case 2:
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._filter = .ownerID(v)}
        case 3:
          var v: Server_TLeaderboardRecordsList.Owners?
          if let current = _storage._filter {
            try decoder.handleConflictingOneOf()
            if case .ownerIds(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._filter = .ownerIds(v)}
        case 4:
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._filter = .lang(v)}
        case 5:
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._filter = .location(v)}
        case 6:
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._filter = .timezone(v)}
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._limit)
        case 8: try decoder.decodeSingularStringField(value: &_storage._cursor)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._leaderboardID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._leaderboardID, fieldNumber: 1)
      }
      switch _storage._filter {
      case .ownerID(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .ownerIds(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .lang(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      case .location(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      case .timezone(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      case nil: break
      }
      if _storage._limit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._limit, fieldNumber: 7)
      }
      if !_storage._cursor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cursor, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TLeaderboardRecords contains a list of leaderboard records.
struct Server_TLeaderboardRecords: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TLeaderboardRecords"

  var records: [Server_LeaderboardRecord] = []

  var cursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.records)
      case 2: try decoder.decodeSingularStringField(value: &self.cursor)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TRpc is used to directly invoke the Lua runtime with the given payload.
/// The script can optionally return some data which will be marshalled into the payload field and sent back to the client.
///
/// @returns TRpc
struct Server_TRpc: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TRpc"

  var id: String = String()

  var payload: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.payload)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TPurchaseValidation is used to validation purchases made by the client.
/// Verify an In-App Purchase receipt from Apple or Google purchases.
///
/// @returns TPurchaseRecord
struct Server_TPurchaseValidation: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TPurchaseValidation"

  var id: OneOf_ID? {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var applePurchase: Server_TPurchaseValidation.ApplePurchase {
    get {
      if case .applePurchase(let v)? = _storage._id {return v}
      return Server_TPurchaseValidation.ApplePurchase()
    }
    set {_uniqueStorage()._id = .applePurchase(newValue)}
  }

  var googlePurchase: Server_TPurchaseValidation.GooglePurchase {
    get {
      if case .googlePurchase(let v)? = _storage._id {return v}
      return Server_TPurchaseValidation.GooglePurchase()
    }
    set {_uniqueStorage()._id = .googlePurchase(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case applePurchase(Server_TPurchaseValidation.ApplePurchase)
    case googlePurchase(Server_TPurchaseValidation.GooglePurchase)

    static func ==(lhs: Server_TPurchaseValidation.OneOf_ID, rhs: Server_TPurchaseValidation.OneOf_ID) -> Bool {
      switch (lhs, rhs) {
      case (.applePurchase(let l), .applePurchase(let r)): return l == r
      case (.googlePurchase(let l), .googlePurchase(let r)): return l == r
      default: return false
      }
    }
  }

  ///*
  /// Verify an In-App Purchase receipt from Apple purchases.
  struct ApplePurchase: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TPurchaseValidation.protoMessageName + ".ApplePurchase"

    /// The product, item, or subscription package ID the purchase relates to.
    var productID: String = String()

    /// The receipt data returned by the purchase operation itself. This must be converted to base64.
    var receiptData: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.productID)
        case 2: try decoder.decodeSingularStringField(value: &self.receiptData)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.productID.isEmpty {
        try visitor.visitSingularStringField(value: self.productID, fieldNumber: 1)
      }
      if !self.receiptData.isEmpty {
        try visitor.visitSingularStringField(value: self.receiptData, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  ///*
  /// Verify an In-App Purchase receipt from Google purchases.
  struct GooglePurchase: SwiftProtobuf.Message {
    static let protoMessageName: String = Server_TPurchaseValidation.protoMessageName + ".GooglePurchase"

    /// The identifier of the product or subscription being purchased.
    var productID: String = String()

    /// Whether the purchase is for a single product or a subscription.
    var productType: String = String()

    /// The token returned in the purchase operation response, acts as a transaction identifier.
    var purchaseToken: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.productID)
        case 2: try decoder.decodeSingularStringField(value: &self.productType)
        case 3: try decoder.decodeSingularStringField(value: &self.purchaseToken)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.productID.isEmpty {
        try visitor.visitSingularStringField(value: self.productID, fieldNumber: 1)
      }
      if !self.productType.isEmpty {
        try visitor.visitSingularStringField(value: self.productType, fieldNumber: 2)
      }
      if !self.purchaseToken.isEmpty {
        try visitor.visitSingularStringField(value: self.purchaseToken, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Server_TPurchaseValidation.ApplePurchase?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .applePurchase(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .applePurchase(v)}
        case 2:
          var v: Server_TPurchaseValidation.GooglePurchase?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .googlePurchase(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .googlePurchase(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._id {
      case .applePurchase(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .googlePurchase(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// TPurchaseRecord is the response of purchase validation
struct Server_TPurchaseRecord: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TPurchaseRecord"

  //// Whether or not the transaction is valid and all the information matches.
  var success: Bool = false

  //// If this is a new transaction or if Nakama has a log of it.
  var seenBefore: Bool = false

  //// Indicates whether or not Nakama was able to reach the remote purchase service.
  var purchaseProviderReachable: Bool = false

  //// A string indicating why the purchase verification failed, if appropriate.
  var message: String = String()

  //// The complete response Nakama received from the remote service.
  var data: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.success)
      case 2: try decoder.decodeSingularBoolField(value: &self.seenBefore)
      case 3: try decoder.decodeSingularBoolField(value: &self.purchaseProviderReachable)
      case 5: try decoder.decodeSingularStringField(value: &self.data)
      case 6: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.seenBefore != false {
      try visitor.visitSingularBoolField(value: self.seenBefore, fieldNumber: 2)
    }
    if self.purchaseProviderReachable != false {
      try visitor.visitSingularBoolField(value: self.purchaseProviderReachable, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 5)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Notification is the core domain type representing an in-app notification.
struct Server_Notification: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Notification"

  var id: String = String()

  var subject: String = String()

  var content: String = String()

  var code: Int64 = 0

  var senderID: String = String()

  var createdAt: Int64 = 0

  var expiresAt: Int64 = 0

  var persistent: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.subject)
      case 3: try decoder.decodeSingularStringField(value: &self.content)
      case 4: try decoder.decodeSingularInt64Field(value: &self.code)
      case 5: try decoder.decodeSingularStringField(value: &self.senderID)
      case 6: try decoder.decodeSingularInt64Field(value: &self.createdAt)
      case 7: try decoder.decodeSingularInt64Field(value: &self.expiresAt)
      case 8: try decoder.decodeSingularBoolField(value: &self.persistent)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    if self.code != 0 {
      try visitor.visitSingularInt64Field(value: self.code, fieldNumber: 4)
    }
    if !self.senderID.isEmpty {
      try visitor.visitSingularStringField(value: self.senderID, fieldNumber: 5)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularInt64Field(value: self.createdAt, fieldNumber: 6)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularInt64Field(value: self.expiresAt, fieldNumber: 7)
    }
    if self.persistent != false {
      try visitor.visitSingularBoolField(value: self.persistent, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// Notification is the core domain type representing a list of live in-app notification.
struct Server_Notifications: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".Notifications"

  var notifications: [Server_Notification] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.notifications)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notifications, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TNotificationsList is used to list unexpired notifications.
struct Server_TNotificationsList: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TNotificationsList"

  //// Max number of notifications to list. Between 10 and 100.
  var limit: Int64 = 0

  //// Use this cursor to paginate notifications.
  //// Cache this to catch up to new notifications.
  //// The value of this comes from TNotifications.resumable_cursor.
  var resumableCursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.limit)
      case 2: try decoder.decodeSingularStringField(value: &self.resumableCursor)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 1)
    }
    if !self.resumableCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.resumableCursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TNotifications is the response of listing notifications
struct Server_TNotifications: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TNotifications"

  var notifications: [Server_Notification] = []

  //// Use this cursor to paginate notifications.
  //// Cache this to catch up to new notifications.
  var resumableCursor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.notifications)
      case 2: try decoder.decodeSingularStringField(value: &self.resumableCursor)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notifications, fieldNumber: 1)
    }
    if !self.resumableCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.resumableCursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

///*
/// TNotificationsRemove is used to delete notifications.
struct Server_TNotificationsRemove: SwiftProtobuf.Message {
  static let protoMessageName: String = _protobuf_package + ".TNotificationsRemove"

  var notificationIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.notificationIds)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notificationIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.notificationIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "server"

extension Server_StoragePermissionRead: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_READ"),
    1: .same(proto: "OWNER_READ"),
    2: .same(proto: "PUBLIC_READ"),
  ]
}

extension Server_StoragePermissionWrite: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_WRITE"),
    1: .same(proto: "OWNER_WRITE"),
  ]
}

extension Server_Heartbeat: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_Heartbeat) -> Bool {
    if self.timestamp != other.timestamp {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Error: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_Error) -> Bool {
    if self.code != other.code {return false}
    if self.message != other.message {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Error.Code: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUNTIME_EXCEPTION"),
    1: .same(proto: "UNRECOGNIZED_PAYLOAD"),
    2: .same(proto: "MISSING_PAYLOAD"),
    3: .same(proto: "BAD_INPUT"),
    4: .same(proto: "AUTH_ERROR"),
    5: .same(proto: "USER_NOT_FOUND"),
    6: .same(proto: "USER_REGISTER_INUSE"),
    7: .same(proto: "USER_LINK_INUSE"),
    8: .same(proto: "USER_LINK_PROVIDER_UNAVAILABLE"),
    9: .same(proto: "USER_UNLINK_DISALLOWED"),
    10: .same(proto: "USER_HANDLE_INUSE"),
    11: .same(proto: "GROUP_NAME_INUSE"),
    12: .same(proto: "GROUP_LAST_ADMIN"),
    13: .same(proto: "STORAGE_REJECTED"),
    14: .same(proto: "MATCH_NOT_FOUND"),
    15: .same(proto: "RUNTIME_FUNCTION_NOT_FOUND"),
    16: .same(proto: "RUNTIME_FUNCTION_EXCEPTION"),
  ]
}

extension Server_AuthenticateRequest: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collationId"),
    2: .same(proto: "email"),
    3: .same(proto: "facebook"),
    4: .same(proto: "google"),
    5: .standard(proto: "game_center"),
    6: .same(proto: "steam"),
    7: .same(proto: "device"),
    8: .same(proto: "custom"),
  ]

  fileprivate class _StorageClass {
    var _collationID: String = String()
    var _id: Server_AuthenticateRequest.OneOf_ID?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collationID = source._collationID
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_AuthenticateRequest) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._collationID != other_storage._collationID {return false}
        if _storage._id != other_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_AuthenticateRequest.Email: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_AuthenticateRequest.Email) -> Bool {
    if self.email != other.email {return false}
    if self.password != other.password {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_AuthenticateRequest.GameCenter: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_id"),
    2: .standard(proto: "bundle_id"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "salt"),
    5: .same(proto: "signature"),
    6: .standard(proto: "public_key_url"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_AuthenticateRequest.GameCenter) -> Bool {
    if self.playerID != other.playerID {return false}
    if self.bundleID != other.bundleID {return false}
    if self.timestamp != other.timestamp {return false}
    if self.salt != other.salt {return false}
    if self.signature != other.signature {return false}
    if self.publicKeyURL != other.publicKeyURL {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_AuthenticateResponse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collation_id"),
    2: .same(proto: "session"),
    3: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _collationID: String = String()
    var _id: Server_AuthenticateResponse.OneOf_ID?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collationID = source._collationID
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_AuthenticateResponse) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._collationID != other_storage._collationID {return false}
        if _storage._id != other_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_AuthenticateResponse.Session: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "udp_token"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_AuthenticateResponse.Session) -> Bool {
    if self.token != other.token {return false}
    if self.udpToken != other.udpToken {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_AuthenticateResponse.Error: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "request"),
  ]

  fileprivate class _StorageClass {
    var _code: Int32 = 0
    var _message: String = String()
    var _request: Server_AuthenticateRequest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _message = source._message
      _request = source._request
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_AuthenticateResponse.Error) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._code != other_storage._code {return false}
        if _storage._message != other_storage._message {return false}
        if _storage._request != other_storage._request {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Envelope: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collation_id"),
    2: .same(proto: "error"),
    3: .same(proto: "heartbeat"),
    4: .same(proto: "logout"),
    5: .same(proto: "link"),
    6: .same(proto: "unlink"),
    7: .standard(proto: "self_fetch"),
    8: .standard(proto: "self_update"),
    9: .standard(proto: "users_fetch"),
    10: .same(proto: "self"),
    11: .same(proto: "users"),
    12: .standard(proto: "friends_add"),
    13: .standard(proto: "friends_remove"),
    14: .standard(proto: "friends_block"),
    15: .standard(proto: "friends_list"),
    16: .same(proto: "friends"),
    17: .standard(proto: "groups_create"),
    18: .standard(proto: "groups_update"),
    19: .standard(proto: "groups_remove"),
    20: .standard(proto: "groups_fetch"),
    21: .standard(proto: "groups_list"),
    22: .standard(proto: "groups_self_list"),
    23: .standard(proto: "group_users_list"),
    24: .standard(proto: "groups_join"),
    25: .standard(proto: "groups_leave"),
    26: .standard(proto: "group_users_add"),
    27: .standard(proto: "group_users_kick"),
    28: .standard(proto: "group_users_promote"),
    29: .same(proto: "groups"),
    30: .standard(proto: "groups_self"),
    31: .standard(proto: "group_users"),
    32: .standard(proto: "topics_join"),
    33: .standard(proto: "topics_leave"),
    34: .standard(proto: "topic_message_send"),
    35: .standard(proto: "topic_messages_list"),
    36: .same(proto: "topics"),
    37: .standard(proto: "topic_message_ack"),
    38: .standard(proto: "topic_message"),
    39: .standard(proto: "topic_messages"),
    40: .standard(proto: "topic_presence"),
    41: .standard(proto: "match_create"),
    42: .standard(proto: "matches_join"),
    43: .standard(proto: "matches_leave"),
    44: .standard(proto: "match_data_send"),
    45: .same(proto: "match"),
    46: .same(proto: "matches"),
    47: .standard(proto: "match_data"),
    48: .standard(proto: "match_presence"),
    49: .standard(proto: "storage_list"),
    50: .standard(proto: "storage_fetch"),
    51: .standard(proto: "storage_write"),
    52: .standard(proto: "storage_update"),
    53: .standard(proto: "storage_remove"),
    54: .standard(proto: "storage_data"),
    55: .standard(proto: "storage_keys"),
    56: .standard(proto: "leaderboards_list"),
    57: .standard(proto: "leaderboard_records_write"),
    58: .standard(proto: "leaderboard_records_fetch"),
    59: .standard(proto: "leaderboard_records_list"),
    60: .same(proto: "leaderboards"),
    61: .standard(proto: "leaderboard_records"),
    62: .standard(proto: "matchmake_add"),
    63: .standard(proto: "matchmake_remove"),
    64: .standard(proto: "matchmake_ticket"),
    65: .standard(proto: "matchmake_matched"),
    66: .same(proto: "rpc"),
    67: .same(proto: "purchase"),
    68: .standard(proto: "purchase_record"),
    69: .standard(proto: "notifications_list"),
    70: .standard(proto: "notifications_remove"),
    71: .same(proto: "notifications"),
    72: .standard(proto: "live_notifications"),
  ]

  fileprivate class _StorageClass {
    var _collationID: String = String()
    var _payload: Server_Envelope.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collationID = source._collationID
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_Envelope) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._collationID != other_storage._collationID {return false}
        if _storage._payload != other_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Logout: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  func _protobuf_generated_isEqualTo(other: Server_Logout) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TLink: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "facebook"),
    3: .same(proto: "google"),
    4: .standard(proto: "game_center"),
    5: .same(proto: "steam"),
    6: .same(proto: "device"),
    7: .same(proto: "custom"),
  ]

  fileprivate class _StorageClass {
    var _id: Server_TLink.OneOf_ID?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TLink) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._id != other_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TUnlink: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "facebook"),
    3: .same(proto: "google"),
    4: .standard(proto: "game_center"),
    5: .same(proto: "steam"),
    6: .same(proto: "device"),
    7: .same(proto: "custom"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TUnlink) -> Bool {
    if self.id != other.id {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_User: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "handle"),
    3: .same(proto: "fullname"),
    4: .standard(proto: "avatar_url"),
    5: .same(proto: "lang"),
    6: .same(proto: "location"),
    7: .same(proto: "timezone"),
    8: .same(proto: "metadata"),
    9: .standard(proto: "created_at"),
    10: .standard(proto: "updated_at"),
    11: .standard(proto: "last_online_at"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_User) -> Bool {
    if self.id != other.id {return false}
    if self.handle != other.handle {return false}
    if self.fullname != other.fullname {return false}
    if self.avatarURL != other.avatarURL {return false}
    if self.lang != other.lang {return false}
    if self.location != other.location {return false}
    if self.timezone != other.timezone {return false}
    if self.metadata != other.metadata {return false}
    if self.createdAt != other.createdAt {return false}
    if self.updatedAt != other.updatedAt {return false}
    if self.lastOnlineAt != other.lastOnlineAt {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Self: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "verified"),
    3: .same(proto: "email"),
    4: .standard(proto: "device_ids"),
    5: .standard(proto: "facebook_id"),
    6: .standard(proto: "google_id"),
    7: .standard(proto: "gamecenter_id"),
    8: .standard(proto: "steam_id"),
    9: .standard(proto: "custom_id"),
  ]

  fileprivate class _StorageClass {
    var _user: Server_User? = nil
    var _verified: Bool = false
    var _email: String = String()
    var _deviceIds: [String] = []
    var _facebookID: String = String()
    var _googleID: String = String()
    var _gamecenterID: String = String()
    var _steamID: String = String()
    var _customID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _verified = source._verified
      _email = source._email
      _deviceIds = source._deviceIds
      _facebookID = source._facebookID
      _googleID = source._googleID
      _gamecenterID = source._gamecenterID
      _steamID = source._steamID
      _customID = source._customID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_Self) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._user != other_storage._user {return false}
        if _storage._verified != other_storage._verified {return false}
        if _storage._email != other_storage._email {return false}
        if _storage._deviceIds != other_storage._deviceIds {return false}
        if _storage._facebookID != other_storage._facebookID {return false}
        if _storage._googleID != other_storage._googleID {return false}
        if _storage._gamecenterID != other_storage._gamecenterID {return false}
        if _storage._steamID != other_storage._steamID {return false}
        if _storage._customID != other_storage._customID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TSelfFetch: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  func _protobuf_generated_isEqualTo(other: Server_TSelfFetch) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TSelf: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "self"),
  ]

  fileprivate class _StorageClass {
    var _self_p: Server_Self? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _self_p = source._self_p
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TSelf) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._self_p != other_storage._self_p {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TSelfUpdate: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handle"),
    2: .same(proto: "fullname"),
    3: .same(proto: "timezone"),
    4: .same(proto: "location"),
    5: .same(proto: "lang"),
    6: .same(proto: "metadata"),
    7: .standard(proto: "avatar_url"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TSelfUpdate) -> Bool {
    if self.handle != other.handle {return false}
    if self.fullname != other.fullname {return false}
    if self.timezone != other.timezone {return false}
    if self.location != other.location {return false}
    if self.lang != other.lang {return false}
    if self.metadata != other.metadata {return false}
    if self.avatarURL != other.avatarURL {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TUsersFetch: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TUsersFetch) -> Bool {
    if self.users != other.users {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TUsersFetch.UsersFetch: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "handle"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TUsersFetch.UsersFetch) -> Bool {
    if self.id != other.id {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TUsers: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TUsers) -> Bool {
    if self.users != other.users {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Friend: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _user: Server_User? = nil
    var _state: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_Friend) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._user != other_storage._user {return false}
        if _storage._state != other_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TFriendsAdd: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friends"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TFriendsAdd) -> Bool {
    if self.friends != other.friends {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TFriendsAdd.FriendsAdd: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "handle"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TFriendsAdd.FriendsAdd) -> Bool {
    if self.id != other.id {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TFriendsRemove: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_ids"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TFriendsRemove) -> Bool {
    if self.userIds != other.userIds {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TFriendsBlock: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_ids"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TFriendsBlock) -> Bool {
    if self.userIds != other.userIds {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TFriendsList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  func _protobuf_generated_isEqualTo(other: Server_TFriendsList) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TFriends: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friends"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TFriends) -> Bool {
    if self.friends != other.friends {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Group: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "private"),
    3: .standard(proto: "creator_id"),
    4: .same(proto: "name"),
    5: .same(proto: "description"),
    6: .standard(proto: "avatar_url"),
    7: .same(proto: "lang"),
    8: .standard(proto: "utc_offset_ms"),
    9: .same(proto: "metadata"),
    10: .same(proto: "count"),
    11: .standard(proto: "created_at"),
    12: .standard(proto: "updated_at"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_Group) -> Bool {
    if self.id != other.id {return false}
    if self.`private` != other.`private` {return false}
    if self.creatorID != other.creatorID {return false}
    if self.name != other.name {return false}
    if self.description_p != other.description_p {return false}
    if self.avatarURL != other.avatarURL {return false}
    if self.lang != other.lang {return false}
    if self.utcOffsetMs != other.utcOffsetMs {return false}
    if self.metadata != other.metadata {return false}
    if self.count != other.count {return false}
    if self.createdAt != other.createdAt {return false}
    if self.updatedAt != other.updatedAt {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsCreate: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsCreate) -> Bool {
    if self.groups != other.groups {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsCreate.GroupCreate: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "avatar_url"),
    4: .same(proto: "lang"),
    5: .same(proto: "metadata"),
    6: .same(proto: "private"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsCreate.GroupCreate) -> Bool {
    if self.name != other.name {return false}
    if self.description_p != other.description_p {return false}
    if self.avatarURL != other.avatarURL {return false}
    if self.lang != other.lang {return false}
    if self.metadata != other.metadata {return false}
    if self.`private` != other.`private` {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsUpdate: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsUpdate) -> Bool {
    if self.groups != other.groups {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsUpdate.GroupUpdate: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "private"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .standard(proto: "avatar_url"),
    6: .same(proto: "lang"),
    7: .same(proto: "metadata"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsUpdate.GroupUpdate) -> Bool {
    if self.groupID != other.groupID {return false}
    if self.`private` != other.`private` {return false}
    if self.name != other.name {return false}
    if self.description_p != other.description_p {return false}
    if self.avatarURL != other.avatarURL {return false}
    if self.lang != other.lang {return false}
    if self.metadata != other.metadata {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsRemove: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_ids"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsRemove) -> Bool {
    if self.groupIds != other.groupIds {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsSelfList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  func _protobuf_generated_isEqualTo(other: Server_TGroupsSelfList) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsFetch: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsFetch) -> Bool {
    if self.groups != other.groups {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsFetch.GroupFetch: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "name"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsFetch.GroupFetch) -> Bool {
    if self.id != other.id {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_limit"),
    2: .standard(proto: "order_by_asc"),
    3: .same(proto: "lang"),
    4: .standard(proto: "created_at"),
    5: .same(proto: "count"),
    7: .same(proto: "cursor"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsList) -> Bool {
    if self.pageLimit != other.pageLimit {return false}
    if self.orderByAsc != other.orderByAsc {return false}
    if self.filter != other.filter {return false}
    if self.cursor != other.cursor {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroups: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
    2: .same(proto: "cursor"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroups) -> Bool {
    if self.groups != other.groups {return false}
    if self.cursor != other.cursor {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsSelf: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "groups_self"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsSelf) -> Bool {
    if self.groupsSelf != other.groupsSelf {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsSelf.GroupSelf: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _group: Server_Group? = nil
    var _state: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _group = source._group
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TGroupsSelf.GroupSelf) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._group != other_storage._group {return false}
        if _storage._state != other_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_GroupUser: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _user: Server_User? = nil
    var _state: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_GroupUser) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._user != other_storage._user {return false}
        if _storage._state != other_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupUsersList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupUsersList) -> Bool {
    if self.groupID != other.groupID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupUsers: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupUsers) -> Bool {
    if self.users != other.users {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsJoin: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_ids"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsJoin) -> Bool {
    if self.groupIds != other.groupIds {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupsLeave: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_ids"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupsLeave) -> Bool {
    if self.groupIds != other.groupIds {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupUsersAdd: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_users"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupUsersAdd) -> Bool {
    if self.groupUsers != other.groupUsers {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupUsersAdd.GroupUserAdd: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupUsersAdd.GroupUserAdd) -> Bool {
    if self.groupID != other.groupID {return false}
    if self.userID != other.userID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupUsersKick: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_users"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupUsersKick) -> Bool {
    if self.groupUsers != other.groupUsers {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupUsersKick.GroupUserKick: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupUsersKick.GroupUserKick) -> Bool {
    if self.groupID != other.groupID {return false}
    if self.userID != other.userID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupUsersPromote: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_users"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupUsersPromote) -> Bool {
    if self.groupUsers != other.groupUsers {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TGroupUsersPromote.GroupUserPromote: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_id"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TGroupUsersPromote.GroupUserPromote) -> Bool {
    if self.groupID != other.groupID {return false}
    if self.userID != other.userID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TopicId: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dm"),
    2: .same(proto: "room"),
    3: .standard(proto: "group_id"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TopicId) -> Bool {
    if self.id != other.id {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_UserPresence: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_id"),
    3: .same(proto: "handle"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_UserPresence) -> Bool {
    if self.userID != other.userID {return false}
    if self.sessionID != other.sessionID {return false}
    if self.handle != other.handle {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TTopicsJoin: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "joins"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TTopicsJoin) -> Bool {
    if self.joins != other.joins {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TTopicsJoin.TopicJoin: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "room"),
    3: .standard(proto: "group_id"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TTopicsJoin.TopicJoin) -> Bool {
    if self.id != other.id {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TTopics: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TTopics) -> Bool {
    if self.topics != other.topics {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TTopics.Topic: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "presences"),
    3: .same(proto: "self"),
  ]

  fileprivate class _StorageClass {
    var _topic: Server_TopicId? = nil
    var _presences: [Server_UserPresence] = []
    var _self_p: Server_UserPresence? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _topic = source._topic
      _presences = source._presences
      _self_p = source._self_p
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TTopics.Topic) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._topic != other_storage._topic {return false}
        if _storage._presences != other_storage._presences {return false}
        if _storage._self_p != other_storage._self_p {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TTopicsLeave: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topics"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TTopicsLeave) -> Bool {
    if self.topics != other.topics {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TTopicMessageSend: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _topic: Server_TopicId? = nil
    var _data: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _topic = source._topic
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TTopicMessageSend) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._topic != other_storage._topic {return false}
        if _storage._data != other_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TTopicMessageAck: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "expires_at"),
    4: .same(proto: "handle"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TTopicMessageAck) -> Bool {
    if self.messageID != other.messageID {return false}
    if self.createdAt != other.createdAt {return false}
    if self.expiresAt != other.expiresAt {return false}
    if self.handle != other.handle {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TopicMessage: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "expires_at"),
    6: .same(proto: "handle"),
    7: .same(proto: "type"),
    8: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _topic: Server_TopicId? = nil
    var _userID: String = String()
    var _messageID: String = String()
    var _createdAt: Int64 = 0
    var _expiresAt: Int64 = 0
    var _handle: String = String()
    var _type: Int64 = 0
    var _data: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _topic = source._topic
      _userID = source._userID
      _messageID = source._messageID
      _createdAt = source._createdAt
      _expiresAt = source._expiresAt
      _handle = source._handle
      _type = source._type
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TopicMessage) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._topic != other_storage._topic {return false}
        if _storage._userID != other_storage._userID {return false}
        if _storage._messageID != other_storage._messageID {return false}
        if _storage._createdAt != other_storage._createdAt {return false}
        if _storage._expiresAt != other_storage._expiresAt {return false}
        if _storage._handle != other_storage._handle {return false}
        if _storage._type != other_storage._type {return false}
        if _storage._data != other_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TTopicMessagesList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "room"),
    3: .standard(proto: "group_id"),
    4: .same(proto: "cursor"),
    5: .same(proto: "forward"),
    6: .same(proto: "limit"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TTopicMessagesList) -> Bool {
    if self.id != other.id {return false}
    if self.cursor != other.cursor {return false}
    if self.forward != other.forward {return false}
    if self.limit != other.limit {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TTopicMessages: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .same(proto: "cursor"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TTopicMessages) -> Bool {
    if self.messages != other.messages {return false}
    if self.cursor != other.cursor {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TopicPresence: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "joins"),
    3: .same(proto: "leaves"),
  ]

  fileprivate class _StorageClass {
    var _topic: Server_TopicId? = nil
    var _joins: [Server_UserPresence] = []
    var _leaves: [Server_UserPresence] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _topic = source._topic
      _joins = source._joins
      _leaves = source._leaves
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TopicPresence) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._topic != other_storage._topic {return false}
        if _storage._joins != other_storage._joins {return false}
        if _storage._leaves != other_storage._leaves {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_PropertyPair: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "stringSet"),
    3: .same(proto: "boolValue"),
    4: .same(proto: "intValue"),
  ]

  fileprivate class _StorageClass {
    var _key: String = String()
    var _value: Server_PropertyPair.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_PropertyPair) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._key != other_storage._key {return false}
        if _storage._value != other_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_PropertyPair.StringSet: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_PropertyPair.StringSet) -> Bool {
    if self.values != other.values {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_MatchmakeFilter: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "term"),
    3: .same(proto: "range"),
    4: .same(proto: "check"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _value: Server_MatchmakeFilter.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_MatchmakeFilter) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._name != other_storage._name {return false}
        if _storage._value != other_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_MatchmakeFilter.TermFilter: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "terms"),
    2: .same(proto: "matchAllTerms"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_MatchmakeFilter.TermFilter) -> Bool {
    if self.terms != other.terms {return false}
    if self.matchAllTerms != other.matchAllTerms {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_MatchmakeFilter.RangeFilter: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lower_bound"),
    2: .standard(proto: "upper_bound"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_MatchmakeFilter.RangeFilter) -> Bool {
    if self.lowerBound != other.lowerBound {return false}
    if self.upperBound != other.upperBound {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TMatchmakeAdd: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "required_count"),
    2: .same(proto: "filters"),
    3: .same(proto: "properties"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TMatchmakeAdd) -> Bool {
    if self.requiredCount != other.requiredCount {return false}
    if self.filters != other.filters {return false}
    if self.properties != other.properties {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TMatchmakeTicket: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticket"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TMatchmakeTicket) -> Bool {
    if self.ticket != other.ticket {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TMatchmakeRemove: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticket"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TMatchmakeRemove) -> Bool {
    if self.ticket != other.ticket {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_MatchmakeMatched: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticket"),
    2: .same(proto: "token"),
    3: .same(proto: "presences"),
    4: .same(proto: "self"),
    5: .same(proto: "properties"),
  ]

  fileprivate class _StorageClass {
    var _ticket: String = String()
    var _token: String = String()
    var _presences: [Server_UserPresence] = []
    var _self_p: Server_UserPresence? = nil
    var _properties: [Server_MatchmakeMatched.UserProperty] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ticket = source._ticket
      _token = source._token
      _presences = source._presences
      _self_p = source._self_p
      _properties = source._properties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_MatchmakeMatched) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._ticket != other_storage._ticket {return false}
        if _storage._token != other_storage._token {return false}
        if _storage._presences != other_storage._presences {return false}
        if _storage._self_p != other_storage._self_p {return false}
        if _storage._properties != other_storage._properties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_MatchmakeMatched.UserProperty: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "properties"),
    3: .same(proto: "filters"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_MatchmakeMatched.UserProperty) -> Bool {
    if self.userID != other.userID {return false}
    if self.properties != other.properties {return false}
    if self.filters != other.filters {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Match: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .same(proto: "presences"),
    3: .same(proto: "self"),
  ]

  fileprivate class _StorageClass {
    var _matchID: String = String()
    var _presences: [Server_UserPresence] = []
    var _self_p: Server_UserPresence? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _matchID = source._matchID
      _presences = source._presences
      _self_p = source._self_p
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_Match) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._matchID != other_storage._matchID {return false}
        if _storage._presences != other_storage._presences {return false}
        if _storage._self_p != other_storage._self_p {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_MatchPresence: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .same(proto: "joins"),
    3: .same(proto: "leaves"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_MatchPresence) -> Bool {
    if self.matchID != other.matchID {return false}
    if self.joins != other.joins {return false}
    if self.leaves != other.leaves {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TMatchCreate: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  func _protobuf_generated_isEqualTo(other: Server_TMatchCreate) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TMatch: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
  ]

  fileprivate class _StorageClass {
    var _match: Server_Match? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _match = source._match
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TMatch) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._match != other_storage._match {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TMatchesJoin: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matches"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TMatchesJoin) -> Bool {
    if self.matches != other.matches {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TMatchesJoin.MatchJoin: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .same(proto: "token"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TMatchesJoin.MatchJoin) -> Bool {
    if self.id != other.id {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TMatches: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matches"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TMatches) -> Bool {
    if self.matches != other.matches {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_MatchDataSend: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .standard(proto: "op_code"),
    3: .same(proto: "data"),
    4: .same(proto: "presences"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_MatchDataSend) -> Bool {
    if self.matchID != other.matchID {return false}
    if self.opCode != other.opCode {return false}
    if self.data != other.data {return false}
    if self.presences != other.presences {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_MatchData: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .same(proto: "presence"),
    3: .standard(proto: "op_code"),
    4: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _matchID: String = String()
    var _presence: Server_UserPresence? = nil
    var _opCode: Int64 = 0
    var _data: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _matchID = source._matchID
      _presence = source._presence
      _opCode = source._opCode
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_MatchData) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._matchID != other_storage._matchID {return false}
        if _storage._presence != other_storage._presence {return false}
        if _storage._opCode != other_storage._opCode {return false}
        if _storage._data != other_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TMatchesLeave: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_ids"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TMatchesLeave) -> Bool {
    if self.matchIds != other.matchIds {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "bucket"),
    3: .same(proto: "collection"),
    4: .same(proto: "limit"),
    5: .same(proto: "cursor"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageList) -> Bool {
    if self.userID != other.userID {return false}
    if self.bucket != other.bucket {return false}
    if self.collection != other.collection {return false}
    if self.limit != other.limit {return false}
    if self.cursor != other.cursor {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageFetch: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageFetch) -> Bool {
    if self.keys != other.keys {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageFetch.StorageKey: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "collection"),
    3: .same(proto: "record"),
    4: .standard(proto: "user_id"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageFetch.StorageKey) -> Bool {
    if self.bucket != other.bucket {return false}
    if self.collection != other.collection {return false}
    if self.record != other.record {return false}
    if self.userID != other.userID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageData: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "cursor"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageData) -> Bool {
    if self.data != other.data {return false}
    if self.cursor != other.cursor {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageData.StorageData: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "collection"),
    3: .same(proto: "record"),
    4: .standard(proto: "user_id"),
    5: .same(proto: "value"),
    6: .same(proto: "version"),
    7: .standard(proto: "permission_read"),
    8: .standard(proto: "permission_write"),
    9: .standard(proto: "created_at"),
    10: .standard(proto: "updated_at"),
    11: .standard(proto: "expires_at"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageData.StorageData) -> Bool {
    if self.bucket != other.bucket {return false}
    if self.collection != other.collection {return false}
    if self.record != other.record {return false}
    if self.userID != other.userID {return false}
    if self.value != other.value {return false}
    if self.version != other.version {return false}
    if self.permissionRead != other.permissionRead {return false}
    if self.permissionWrite != other.permissionWrite {return false}
    if self.createdAt != other.createdAt {return false}
    if self.updatedAt != other.updatedAt {return false}
    if self.expiresAt != other.expiresAt {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageWrite: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "data"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageWrite) -> Bool {
    if self.data != other.data {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageWrite.StorageData: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "collection"),
    3: .same(proto: "record"),
    4: .same(proto: "value"),
    5: .same(proto: "version"),
    6: .standard(proto: "permission_read"),
    7: .standard(proto: "permission_write"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageWrite.StorageData) -> Bool {
    if self.bucket != other.bucket {return false}
    if self.collection != other.collection {return false}
    if self.record != other.record {return false}
    if self.value != other.value {return false}
    if self.version != other.version {return false}
    if self.permissionRead != other.permissionRead {return false}
    if self.permissionWrite != other.permissionWrite {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageUpdate: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageUpdate) -> Bool {
    if self.updates != other.updates {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageUpdate.StorageUpdate: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "permission_read"),
    3: .standard(proto: "permission_write"),
    4: .same(proto: "ops"),
  ]

  fileprivate class _StorageClass {
    var _key: Server_TStorageUpdate.StorageUpdate.StorageKey? = nil
    var _permissionRead: Int32 = 0
    var _permissionWrite: Int32 = 0
    var _ops: [Server_TStorageUpdate.StorageUpdate.UpdateOp] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _permissionRead = source._permissionRead
      _permissionWrite = source._permissionWrite
      _ops = source._ops
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TStorageUpdate.StorageUpdate) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._key != other_storage._key {return false}
        if _storage._permissionRead != other_storage._permissionRead {return false}
        if _storage._permissionWrite != other_storage._permissionWrite {return false}
        if _storage._ops != other_storage._ops {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageUpdate.StorageUpdate.UpdateOp: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "path"),
    3: .same(proto: "value"),
    4: .same(proto: "from"),
    5: .same(proto: "conditional"),
    6: .same(proto: "assert"),
    7: .same(proto: "ops"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageUpdate.StorageUpdate.UpdateOp) -> Bool {
    if self.op != other.op {return false}
    if self.path != other.path {return false}
    if self.value != other.value {return false}
    if self.from != other.from {return false}
    if self.conditional != other.conditional {return false}
    if self.assert != other.assert {return false}
    if self.ops != other.ops {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageUpdate.StorageUpdate.UpdateOp.UpdateOpCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "APPEND"),
    2: .same(proto: "COPY"),
    3: .same(proto: "INCR"),
    4: .same(proto: "INIT"),
    5: .same(proto: "MERGE"),
    6: .same(proto: "MOVE"),
    7: .same(proto: "PATCH"),
    8: .same(proto: "REMOVE"),
    9: .same(proto: "REPLACE"),
    10: .same(proto: "TEST"),
    11: .same(proto: "COMPARE"),
  ]
}

extension Server_TStorageUpdate.StorageUpdate.StorageKey: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "collection"),
    3: .same(proto: "record"),
    4: .same(proto: "version"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageUpdate.StorageUpdate.StorageKey) -> Bool {
    if self.bucket != other.bucket {return false}
    if self.collection != other.collection {return false}
    if self.record != other.record {return false}
    if self.version != other.version {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageKeys: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageKeys) -> Bool {
    if self.keys != other.keys {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageKeys.StorageKey: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "collection"),
    3: .same(proto: "record"),
    4: .same(proto: "version"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageKeys.StorageKey) -> Bool {
    if self.bucket != other.bucket {return false}
    if self.collection != other.collection {return false}
    if self.record != other.record {return false}
    if self.version != other.version {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageRemove: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageRemove) -> Bool {
    if self.keys != other.keys {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TStorageRemove.StorageKey: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "collection"),
    3: .same(proto: "record"),
    4: .same(proto: "version"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TStorageRemove.StorageKey) -> Bool {
    if self.bucket != other.bucket {return false}
    if self.collection != other.collection {return false}
    if self.record != other.record {return false}
    if self.version != other.version {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Leaderboard: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "authoritative"),
    3: .same(proto: "sort"),
    4: .same(proto: "count"),
    5: .standard(proto: "reset_schedule"),
    6: .same(proto: "metadata"),
    7: .standard(proto: "next_id"),
    8: .standard(proto: "prev_id"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_Leaderboard) -> Bool {
    if self.id != other.id {return false}
    if self.authoritative != other.authoritative {return false}
    if self.sort != other.sort {return false}
    if self.count != other.count {return false}
    if self.resetSchedule != other.resetSchedule {return false}
    if self.metadata != other.metadata {return false}
    if self.nextID != other.nextID {return false}
    if self.prevID != other.prevID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_LeaderboardRecord: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
    2: .standard(proto: "owner_id"),
    3: .same(proto: "handle"),
    4: .same(proto: "lang"),
    5: .same(proto: "location"),
    6: .same(proto: "timezone"),
    7: .same(proto: "rank"),
    8: .same(proto: "score"),
    9: .standard(proto: "num_score"),
    10: .same(proto: "metadata"),
    11: .standard(proto: "ranked_at"),
    12: .standard(proto: "updated_at"),
    13: .standard(proto: "expires_at"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_LeaderboardRecord) -> Bool {
    if self.leaderboardID != other.leaderboardID {return false}
    if self.ownerID != other.ownerID {return false}
    if self.handle != other.handle {return false}
    if self.lang != other.lang {return false}
    if self.location != other.location {return false}
    if self.timezone != other.timezone {return false}
    if self.rank != other.rank {return false}
    if self.score != other.score {return false}
    if self.numScore != other.numScore {return false}
    if self.metadata != other.metadata {return false}
    if self.rankedAt != other.rankedAt {return false}
    if self.updatedAt != other.updatedAt {return false}
    if self.expiresAt != other.expiresAt {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TLeaderboardsList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .same(proto: "cursor"),
    3: .standard(proto: "filter_leaderboard_id"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TLeaderboardsList) -> Bool {
    if self.limit != other.limit {return false}
    if self.cursor != other.cursor {return false}
    if self.filterLeaderboardID != other.filterLeaderboardID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TLeaderboards: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "leaderboards"),
    2: .same(proto: "cursor"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TLeaderboards) -> Bool {
    if self.leaderboards != other.leaderboards {return false}
    if self.cursor != other.cursor {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TLeaderboardRecordsWrite: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "records"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TLeaderboardRecordsWrite) -> Bool {
    if self.records != other.records {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TLeaderboardRecordsWrite.LeaderboardRecordWrite: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
    2: .same(proto: "incr"),
    3: .same(proto: "decr"),
    4: .same(proto: "set"),
    5: .same(proto: "best"),
    6: .same(proto: "location"),
    7: .same(proto: "timezone"),
    8: .same(proto: "metadata"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TLeaderboardRecordsWrite.LeaderboardRecordWrite) -> Bool {
    if self.leaderboardID != other.leaderboardID {return false}
    if self.op != other.op {return false}
    if self.location != other.location {return false}
    if self.timezone != other.timezone {return false}
    if self.metadata != other.metadata {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TLeaderboardRecordsFetch: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_ids"),
    2: .same(proto: "limit"),
    3: .same(proto: "cursor"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TLeaderboardRecordsFetch) -> Bool {
    if self.leaderboardIds != other.leaderboardIds {return false}
    if self.limit != other.limit {return false}
    if self.cursor != other.cursor {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TLeaderboardRecordsList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
    2: .standard(proto: "owner_id"),
    3: .standard(proto: "owner_ids"),
    4: .same(proto: "lang"),
    5: .same(proto: "location"),
    6: .same(proto: "timezone"),
    7: .same(proto: "limit"),
    8: .same(proto: "cursor"),
  ]

  fileprivate class _StorageClass {
    var _leaderboardID: String = String()
    var _filter: Server_TLeaderboardRecordsList.OneOf_Filter?
    var _limit: Int64 = 0
    var _cursor: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _leaderboardID = source._leaderboardID
      _filter = source._filter
      _limit = source._limit
      _cursor = source._cursor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TLeaderboardRecordsList) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._leaderboardID != other_storage._leaderboardID {return false}
        if _storage._filter != other_storage._filter {return false}
        if _storage._limit != other_storage._limit {return false}
        if _storage._cursor != other_storage._cursor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TLeaderboardRecordsList.Owners: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_ids"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TLeaderboardRecordsList.Owners) -> Bool {
    if self.ownerIds != other.ownerIds {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TLeaderboardRecords: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "records"),
    2: .same(proto: "cursor"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TLeaderboardRecords) -> Bool {
    if self.records != other.records {return false}
    if self.cursor != other.cursor {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TRpc: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "payload"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TRpc) -> Bool {
    if self.id != other.id {return false}
    if self.payload != other.payload {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TPurchaseValidation: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "apple_purchase"),
    2: .standard(proto: "google_purchase"),
  ]

  fileprivate class _StorageClass {
    var _id: Server_TPurchaseValidation.OneOf_ID?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: Server_TPurchaseValidation) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._id != other_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TPurchaseValidation.ApplePurchase: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "product_id"),
    2: .standard(proto: "receipt_data"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TPurchaseValidation.ApplePurchase) -> Bool {
    if self.productID != other.productID {return false}
    if self.receiptData != other.receiptData {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TPurchaseValidation.GooglePurchase: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "product_id"),
    2: .standard(proto: "product_type"),
    3: .standard(proto: "purchase_token"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TPurchaseValidation.GooglePurchase) -> Bool {
    if self.productID != other.productID {return false}
    if self.productType != other.productType {return false}
    if self.purchaseToken != other.purchaseToken {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TPurchaseRecord: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "seen_before"),
    3: .standard(proto: "purchase_provider_reachable"),
    6: .same(proto: "message"),
    5: .same(proto: "data"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TPurchaseRecord) -> Bool {
    if self.success != other.success {return false}
    if self.seenBefore != other.seenBefore {return false}
    if self.purchaseProviderReachable != other.purchaseProviderReachable {return false}
    if self.message != other.message {return false}
    if self.data != other.data {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Notification: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "subject"),
    3: .same(proto: "content"),
    4: .same(proto: "code"),
    5: .standard(proto: "sender_id"),
    6: .standard(proto: "created_at"),
    7: .standard(proto: "expires_at"),
    8: .same(proto: "persistent"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_Notification) -> Bool {
    if self.id != other.id {return false}
    if self.subject != other.subject {return false}
    if self.content != other.content {return false}
    if self.code != other.code {return false}
    if self.senderID != other.senderID {return false}
    if self.createdAt != other.createdAt {return false}
    if self.expiresAt != other.expiresAt {return false}
    if self.persistent != other.persistent {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_Notifications: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifications"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_Notifications) -> Bool {
    if self.notifications != other.notifications {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TNotificationsList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .standard(proto: "resumable_cursor"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TNotificationsList) -> Bool {
    if self.limit != other.limit {return false}
    if self.resumableCursor != other.resumableCursor {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TNotifications: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifications"),
    2: .standard(proto: "resumable_cursor"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TNotifications) -> Bool {
    if self.notifications != other.notifications {return false}
    if self.resumableCursor != other.resumableCursor {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Server_TNotificationsRemove: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "notification_ids"),
  ]

  func _protobuf_generated_isEqualTo(other: Server_TNotificationsRemove) -> Bool {
    if self.notificationIds != other.notificationIds {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
