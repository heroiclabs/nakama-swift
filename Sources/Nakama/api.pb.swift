// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: github.com/heroiclabs/nakama-common/api/api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

///*
/// The Nakama server RPC protocol for games and apps.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A user with additional account details. Always the current user.
public struct Nakama_Api_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user object.
  public var user: Nakama_Api_User {
    get {return _user ?? Nakama_Api_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  /// The user's wallet data.
  public var wallet: String = String()

  /// The email address of the user.
  public var email: String = String()

  /// The devices which belong to the user's account.
  public var devices: [Nakama_Api_AccountDevice] = []

  /// The custom id in the user's account.
  public var customID: String = String()

  /// The UNIX time when the user's email was verified.
  public var verifyTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _verifyTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_verifyTime = newValue}
  }
  /// Returns true if `verifyTime` has been explicitly set.
  public var hasVerifyTime: Bool {return self._verifyTime != nil}
  /// Clears the value of `verifyTime`. Subsequent reads from it will return its default value.
  public mutating func clearVerifyTime() {self._verifyTime = nil}

  /// The UNIX time when the user's account was disabled/banned.
  public var disableTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _disableTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_disableTime = newValue}
  }
  /// Returns true if `disableTime` has been explicitly set.
  public var hasDisableTime: Bool {return self._disableTime != nil}
  /// Clears the value of `disableTime`. Subsequent reads from it will return its default value.
  public mutating func clearDisableTime() {self._disableTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: Nakama_Api_User? = nil
  fileprivate var _verifyTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _disableTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Send a Apple Sign In token to the server. Used with authenticate/link/unlink.
public struct Nakama_Api_AccountApple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID token received from Apple to validate.
  public var token: String = String()

  /// Extra information that will be bundled in the session token.
  public var vars: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send a custom ID to the server. Used with authenticate/link/unlink.
public struct Nakama_Api_AccountCustom {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A custom identifier.
  public var id: String = String()

  /// Extra information that will be bundled in the session token.
  public var vars: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send a device to the server. Used with authenticate/link/unlink and user.
public struct Nakama_Api_AccountDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A device identifier. Should be obtained by a platform-specific device API.
  public var id: String = String()

  /// Extra information that will be bundled in the session token.
  public var vars: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send an email with password to the server. Used with authenticate/link/unlink.
public struct Nakama_Api_AccountEmail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A valid RFC-5322 email address.
  public var email: String = String()

  /// A password for the user account.
  public var password: String = String()

  /// Extra information that will be bundled in the session token.
  public var vars: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send a Facebook token to the server. Used with authenticate/link/unlink.
public struct Nakama_Api_AccountFacebook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The OAuth token received from Facebook to access their profile API.
  public var token: String = String()

  /// Extra information that will be bundled in the session token.
  public var vars: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink.
public struct Nakama_Api_AccountFacebookInstantGame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The OAuth token received from a Facebook Instant Game that may be decoded with the Application Secret (must be available with the nakama configuration)
  public var signedPlayerInfo: String = String()

  /// Extra information that will be bundled in the session token.
  public var vars: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.
public struct Nakama_Api_AccountGameCenter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Player ID (generated by GameCenter).
  public var playerID: String = String()

  /// Bundle ID (generated by GameCenter).
  public var bundleID: String = String()

  /// Time since UNIX epoch when the signature was created.
  public var timestampSeconds: Int64 = 0

  /// A random "NSString" used to compute the hash and keep it randomized.
  public var salt: String = String()

  /// The verification signature data generated.
  public var signature: String = String()

  /// The URL for the public encryption key.
  public var publicKeyURL: String = String()

  /// Extra information that will be bundled in the session token.
  public var vars: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send a Google token to the server. Used with authenticate/link/unlink.
public struct Nakama_Api_AccountGoogle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The OAuth token received from Google to access their profile API.
  public var token: String = String()

  /// Extra information that will be bundled in the session token.
  public var vars: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Send a Steam token to the server. Used with authenticate/link/unlink.
public struct Nakama_Api_AccountSteam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account token received from Steam to access their profile API.
  public var token: String = String()

  /// Extra information that will be bundled in the session token.
  public var vars: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Add one or more friends to the current user.
public struct Nakama_Api_AddFriendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account id of a user.
  public var ids: [String] = []

  /// The account username of a user.
  public var usernames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Add users to a group.
public struct Nakama_Api_AddGroupUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group to add users to.
  public var groupID: String = String()

  /// The users to add.
  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Authenticate against the server with Apple Sign In.
public struct Nakama_Api_AuthenticateAppleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Apple account details.
  public var account: Nakama_Api_AccountApple {
    get {return _account ?? Nakama_Api_AccountApple()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Register the account if the user does not already exist.
  public var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  public var hasCreate: Bool {return self._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  public mutating func clearCreate() {self._create = nil}

  /// Set the username on the account at register. Must be unique.
  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountApple? = nil
  fileprivate var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Authenticate against the server with a custom ID.
public struct Nakama_Api_AuthenticateCustomRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The custom account details.
  public var account: Nakama_Api_AccountCustom {
    get {return _account ?? Nakama_Api_AccountCustom()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Register the account if the user does not already exist.
  public var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  public var hasCreate: Bool {return self._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  public mutating func clearCreate() {self._create = nil}

  /// Set the username on the account at register. Must be unique.
  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountCustom? = nil
  fileprivate var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Authenticate against the server with a device ID.
public struct Nakama_Api_AuthenticateDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The device account details.
  public var account: Nakama_Api_AccountDevice {
    get {return _account ?? Nakama_Api_AccountDevice()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Register the account if the user does not already exist.
  public var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  public var hasCreate: Bool {return self._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  public mutating func clearCreate() {self._create = nil}

  /// Set the username on the account at register. Must be unique.
  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountDevice? = nil
  fileprivate var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Authenticate against the server with email+password.
public struct Nakama_Api_AuthenticateEmailRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The email account details.
  public var account: Nakama_Api_AccountEmail {
    get {return _account ?? Nakama_Api_AccountEmail()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Register the account if the user does not already exist.
  public var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  public var hasCreate: Bool {return self._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  public mutating func clearCreate() {self._create = nil}

  /// Set the username on the account at register. Must be unique.
  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountEmail? = nil
  fileprivate var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Authenticate against the server with Facebook.
public struct Nakama_Api_AuthenticateFacebookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Facebook account details.
  public var account: Nakama_Api_AccountFacebook {
    get {return _account ?? Nakama_Api_AccountFacebook()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Register the account if the user does not already exist.
  public var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  public var hasCreate: Bool {return self._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  public mutating func clearCreate() {self._create = nil}

  /// Set the username on the account at register. Must be unique.
  public var username: String = String()

  /// Import Facebook friends for the user.
  public var sync: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _sync ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_sync = newValue}
  }
  /// Returns true if `sync` has been explicitly set.
  public var hasSync: Bool {return self._sync != nil}
  /// Clears the value of `sync`. Subsequent reads from it will return its default value.
  public mutating func clearSync() {self._sync = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountFacebook? = nil
  fileprivate var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _sync: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Authenticate against the server with Facebook Instant Game token.
public struct Nakama_Api_AuthenticateFacebookInstantGameRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Facebook Instant Game account details.
  public var account: Nakama_Api_AccountFacebookInstantGame {
    get {return _account ?? Nakama_Api_AccountFacebookInstantGame()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Register the account if the user does not already exist.
  public var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  public var hasCreate: Bool {return self._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  public mutating func clearCreate() {self._create = nil}

  /// Set the username on the account at register. Must be unique.
  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountFacebookInstantGame? = nil
  fileprivate var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Authenticate against the server with Apple's Game Center.
public struct Nakama_Api_AuthenticateGameCenterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Game Center account details.
  public var account: Nakama_Api_AccountGameCenter {
    get {return _account ?? Nakama_Api_AccountGameCenter()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Register the account if the user does not already exist.
  public var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  public var hasCreate: Bool {return self._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  public mutating func clearCreate() {self._create = nil}

  /// Set the username on the account at register. Must be unique.
  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountGameCenter? = nil
  fileprivate var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Authenticate against the server with Google.
public struct Nakama_Api_AuthenticateGoogleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google account details.
  public var account: Nakama_Api_AccountGoogle {
    get {return _account ?? Nakama_Api_AccountGoogle()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Register the account if the user does not already exist.
  public var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  public var hasCreate: Bool {return self._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  public mutating func clearCreate() {self._create = nil}

  /// Set the username on the account at register. Must be unique.
  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountGoogle? = nil
  fileprivate var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Authenticate against the server with Steam.
public struct Nakama_Api_AuthenticateSteamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Steam account details.
  public var account: Nakama_Api_AccountSteam {
    get {return _account ?? Nakama_Api_AccountSteam()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Register the account if the user does not already exist.
  public var create: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _create ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_create = newValue}
  }
  /// Returns true if `create` has been explicitly set.
  public var hasCreate: Bool {return self._create != nil}
  /// Clears the value of `create`. Subsequent reads from it will return its default value.
  public mutating func clearCreate() {self._create = nil}

  /// Set the username on the account at register. Must be unique.
  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountSteam? = nil
  fileprivate var _create: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Ban users from a group.
public struct Nakama_Api_BanGroupUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group to ban users from.
  public var groupID: String = String()

  /// The users to ban.
  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Block one or more friends for the current user.
public struct Nakama_Api_BlockFriendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account id of a user.
  public var ids: [String] = []

  /// The account username of a user.
  public var usernames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message sent on a channel.
public struct Nakama_Api_ChannelMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The channel this message belongs to.
  public var channelID: String = String()

  /// The unique ID of this message.
  public var messageID: String = String()

  /// The code representing a message type or category.
  public var code: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _code ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  public var hasCode: Bool {return self._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  public mutating func clearCode() {self._code = nil}

  /// Message sender, usually a user ID.
  public var senderID: String = String()

  /// The username of the message sender, if any.
  public var username: String = String()

  /// The content payload.
  public var content: String = String()

  /// The UNIX time when the message was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// The UNIX time when the message was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// True if the message was persisted to the channel's history, false otherwise.
  public var persistent: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _persistent ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_persistent = newValue}
  }
  /// Returns true if `persistent` has been explicitly set.
  public var hasPersistent: Bool {return self._persistent != nil}
  /// Clears the value of `persistent`. Subsequent reads from it will return its default value.
  public mutating func clearPersistent() {self._persistent = nil}

  /// The name of the chat room, or an empty string if this message was not sent through a chat room.
  public var roomName: String = String()

  /// The ID of the group, or an empty string if this message was not sent through a group channel.
  public var groupID: String = String()

  /// The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
  public var userIDOne: String = String()

  /// The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
  public var userIDTwo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _code: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _persistent: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// A list of channel messages, usually a result of a list operation.
public struct Nakama_Api_ChannelMessageList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of messages.
  public var messages: [Nakama_Api_ChannelMessage] = []

  /// The cursor to send when retrieving the next page, if any.
  public var nextCursor: String = String()

  /// The cursor to send when retrieving the previous page, if any.
  public var prevCursor: String = String()

  /// Cacheable cursor to list newer messages. Durable and designed to be stored, unlike next/prev cursors.
  public var cacheableCursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Create a group with the current user as owner.
public struct Nakama_Api_CreateGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique name for the group.
  public var name: String = String()

  /// A description for the group.
  public var description_p: String = String()

  /// The language expected to be a tag which follows the BCP-47 spec.
  public var langTag: String = String()

  /// A URL for an avatar image.
  public var avatarURL: String = String()

  /// Mark a group as open or not where only admins can accept members.
  public var `open`: Bool = false

  /// Maximum number of group members.
  public var maxCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Delete one or more friends for the current user.
public struct Nakama_Api_DeleteFriendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account id of a user.
  public var ids: [String] = []

  /// The account username of a user.
  public var usernames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Delete a group the user has access to.
public struct Nakama_Api_DeleteGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of a group.
  public var groupID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Delete a leaderboard record.
public struct Nakama_Api_DeleteLeaderboardRecordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The leaderboard ID to delete from.
  public var leaderboardID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Delete one or more notifications for the current user.
public struct Nakama_Api_DeleteNotificationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of notifications.
  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Storage objects to delete.
public struct Nakama_Api_DeleteStorageObjectId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection which stores the object.
  public var collection: String = String()

  /// The key of the object within the collection.
  public var key: String = String()

  /// The version hash of the object.
  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Batch delete storage objects.
public struct Nakama_Api_DeleteStorageObjectsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Batch of storage objects.
  public var objectIds: [Nakama_Api_DeleteStorageObjectId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents an event to be passed through the server to registered event handlers.
public struct Nakama_Api_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An event name, type, category, or identifier.
  public var name: String = String()

  /// Arbitrary event property values.
  public var properties: Dictionary<String,String> = [:]

  /// The time when the event was triggered.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// True if the event came directly from a client call, false otherwise.
  public var external: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A friend of a user.
public struct Nakama_Api_Friend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user object.
  public var user: Nakama_Api_User {
    get {return _user ?? Nakama_Api_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  /// The friend status.
  public var state: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _state ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  /// Time of the latest relationship update.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The friendship status.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The user is a friend of the current user.
    case friend // = 0

    /// The current user has sent an invite to the user.
    case inviteSent // = 1

    /// The current user has received an invite from this user.
    case inviteReceived // = 2

    /// The current user has blocked this user.
    case blocked // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .friend
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .friend
      case 1: self = .inviteSent
      case 2: self = .inviteReceived
      case 3: self = .blocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .friend: return 0
      case .inviteSent: return 1
      case .inviteReceived: return 2
      case .blocked: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _user: Nakama_Api_User? = nil
  fileprivate var _state: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Nakama_Api_Friend.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Nakama_Api_Friend.State] = [
    .friend,
    .inviteSent,
    .inviteReceived,
    .blocked,
  ]
}

#endif  // swift(>=4.2)

/// A collection of zero or more friends of the user.
public struct Nakama_Api_FriendList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Friend objects.
  public var friends: [Nakama_Api_Friend] = []

  /// Cursor for the next page of results, if any.
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Fetch a batch of zero or more users from the server.
public struct Nakama_Api_GetUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account id of a user.
  public var ids: [String] = []

  /// The account username of a user.
  public var usernames: [String] = []

  /// The Facebook ID of a user.
  public var facebookIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A group in the server.
public struct Nakama_Api_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of a group.
  public var id: String = String()

  /// The id of the user who created the group.
  public var creatorID: String = String()

  /// The unique name of the group.
  public var name: String = String()

  /// A description for the group.
  public var description_p: String = String()

  /// The language expected to be a tag which follows the BCP-47 spec.
  public var langTag: String = String()

  /// Additional information stored as a JSON object.
  public var metadata: String = String()

  /// A URL for an avatar image.
  public var avatarURL: String = String()

  /// Anyone can join open groups, otherwise only admins can accept members.
  public var `open`: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _open ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  /// The current count of all members in the group.
  public var edgeCount: Int32 = 0

  /// The maximum number of members allowed.
  public var maxCount: Int32 = 0

  /// The UNIX time when the group was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// The UNIX time when the group was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _open: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// One or more groups returned from a listing operation.
public struct Nakama_Api_GroupList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One or more groups.
  public var groups: [Nakama_Api_Group] = []

  /// A cursor used to get the next page.
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A list of users belonging to a group, along with their role.
public struct Nakama_Api_GroupUserList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User-role pairs for a group.
  public var groupUsers: [Nakama_Api_GroupUserList.GroupUser] = []

  /// Cursor for the next page of results, if any.
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single user-role pair.
  public struct GroupUser {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User.
    public var user: Nakama_Api_User {
      get {return _user ?? Nakama_Api_User()}
      set {_user = newValue}
    }
    /// Returns true if `user` has been explicitly set.
    public var hasUser: Bool {return self._user != nil}
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    public mutating func clearUser() {self._user = nil}

    /// Their relationship to the group.
    public var state: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _state ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_state = newValue}
    }
    /// Returns true if `state` has been explicitly set.
    public var hasState: Bool {return self._state != nil}
    /// Clears the value of `state`. Subsequent reads from it will return its default value.
    public mutating func clearState() {self._state = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The group role status.
    public enum State: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The user is a superadmin with full control of the group.
      case superadmin // = 0

      /// The user is an admin with additional privileges.
      case admin // = 1

      /// The user is a regular member.
      case member // = 2

      /// The user has requested to join the group
      case joinRequest // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .superadmin
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .superadmin
        case 1: self = .admin
        case 2: self = .member
        case 3: self = .joinRequest
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .superadmin: return 0
        case .admin: return 1
        case .member: return 2
        case .joinRequest: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _user: Nakama_Api_User? = nil
    fileprivate var _state: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  }

  public init() {}
}

#if swift(>=4.2)

extension Nakama_Api_GroupUserList.GroupUser.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Nakama_Api_GroupUserList.GroupUser.State] = [
    .superadmin,
    .admin,
    .member,
    .joinRequest,
  ]
}

#endif  // swift(>=4.2)

/// Import Facebook friends into the current user's account.
public struct Nakama_Api_ImportFacebookFriendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Facebook account details.
  public var account: Nakama_Api_AccountFacebook {
    get {return _account ?? Nakama_Api_AccountFacebook()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Reset the current user's friends list.
  public var reset: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _reset ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_reset = newValue}
  }
  /// Returns true if `reset` has been explicitly set.
  public var hasReset: Bool {return self._reset != nil}
  /// Clears the value of `reset`. Subsequent reads from it will return its default value.
  public mutating func clearReset() {self._reset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountFacebook? = nil
  fileprivate var _reset: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Immediately join an open group, or request to join a closed one.
public struct Nakama_Api_JoinGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to join. The group must already exist.
  public var groupID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request to join a tournament.
public struct Nakama_Api_JoinTournamentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the tournament to join. The tournament must already exist.
  public var tournamentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Kick a set of users from a group.
public struct Nakama_Api_KickGroupUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to kick from.
  public var groupID: String = String()

  /// The users to kick.
  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a complete leaderboard record with all scores and associated metadata.
public struct Nakama_Api_LeaderboardRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the leaderboard this score belongs to.
  public var leaderboardID: String = String()

  /// The ID of the score owner, usually a user or group.
  public var ownerID: String = String()

  /// The username of the score owner, if the owner is a user.
  public var username: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _username ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  public var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  public mutating func clearUsername() {self._username = nil}

  /// The score value.
  public var score: Int64 = 0

  /// An optional subscore value.
  public var subscore: Int64 = 0

  /// The number of submissions to this score record.
  public var numScore: Int32 = 0

  /// Metadata.
  public var metadata: String = String()

  /// The UNIX time when the leaderboard record was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// The UNIX time when the leaderboard record was updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// The UNIX time when the leaderboard record expires.
  public var expiryTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiryTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiryTime = newValue}
  }
  /// Returns true if `expiryTime` has been explicitly set.
  public var hasExpiryTime: Bool {return self._expiryTime != nil}
  /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpiryTime() {self._expiryTime = nil}

  /// The rank of this record.
  public var rank: Int64 = 0

  /// The maximum number of score updates allowed by the owner.
  public var maxNumScore: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _username: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expiryTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
public struct Nakama_Api_LeaderboardRecordList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of leaderboard records.
  public var records: [Nakama_Api_LeaderboardRecord] = []

  /// A batched set of leaderboard records belonging to specified owners.
  public var ownerRecords: [Nakama_Api_LeaderboardRecord] = []

  /// The cursor to send when retrieving the next page, if any.
  public var nextCursor: String = String()

  /// The cursor to send when retrieving the previous page, if any.
  public var prevCursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Leave a group.
public struct Nakama_Api_LeaveGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to leave.
  public var groupID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Link Facebook to the current user's account.
public struct Nakama_Api_LinkFacebookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Facebook account details.
  public var account: Nakama_Api_AccountFacebook {
    get {return _account ?? Nakama_Api_AccountFacebook()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  /// Import Facebook friends for the user.
  public var sync: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _sync ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_sync = newValue}
  }
  /// Returns true if `sync` has been explicitly set.
  public var hasSync: Bool {return self._sync != nil}
  /// Clears the value of `sync`. Subsequent reads from it will return its default value.
  public mutating func clearSync() {self._sync = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Nakama_Api_AccountFacebook? = nil
  fileprivate var _sync: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// List a channel's message history.
public struct Nakama_Api_ListChannelMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The channel ID to list from.
  public var channelID: String = String()

  /// Max number of records to return. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// True if listing should be older messages to newer, false if reverse.
  public var forward: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _forward ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_forward = newValue}
  }
  /// Returns true if `forward` has been explicitly set.
  public var hasForward: Bool {return self._forward != nil}
  /// Clears the value of `forward`. Subsequent reads from it will return its default value.
  public mutating func clearForward() {self._forward = nil}

  /// A pagination cursor, if any.
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _forward: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// List friends for a user.
public struct Nakama_Api_ListFriendsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Max number of records to return. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// The friend state to list.
  public var state: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _state ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  /// An optional next page cursor.
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _state: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

/// List groups based on given filters.
public struct Nakama_Api_ListGroupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List groups that contain this value in their names.
  public var name: String = String()

  /// Optional pagination cursor.
  public var cursor: String = String()

  /// Max number of groups to return. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

/// List all users that are part of a group.
public struct Nakama_Api_ListGroupUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to list from.
  public var groupID: String = String()

  /// Max number of records to return. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// The group user state to list.
  public var state: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _state ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  /// An optional next page cursor.
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _state: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

/// List leaerboard records from a given leaderboard around the owner.
public struct Nakama_Api_ListLeaderboardRecordsAroundOwnerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the tournament to list for.
  public var leaderboardID: String = String()

  /// Max number of records to return. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// The owner to retrieve records around.
  public var ownerID: String = String()

  /// Expiry in seconds (since epoch) to begin fetching records from.
  public var expiry: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _expiry ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_expiry = newValue}
  }
  /// Returns true if `expiry` has been explicitly set.
  public var hasExpiry: Bool {return self._expiry != nil}
  /// Clears the value of `expiry`. Subsequent reads from it will return its default value.
  public mutating func clearExpiry() {self._expiry = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _expiry: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// List leaderboard records from a given leaderboard.
public struct Nakama_Api_ListLeaderboardRecordsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the leaderboard to list for.
  public var leaderboardID: String = String()

  /// One or more owners to retrieve records for.
  public var ownerIds: [String] = []

  /// Max number of records to return. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// A next or previous page cursor.
  public var cursor: String = String()

  /// Expiry in seconds (since epoch) to begin fetching records from. Optional. 0 means from current time.
  public var expiry: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _expiry ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_expiry = newValue}
  }
  /// Returns true if `expiry` has been explicitly set.
  public var hasExpiry: Bool {return self._expiry != nil}
  /// Clears the value of `expiry`. Subsequent reads from it will return its default value.
  public mutating func clearExpiry() {self._expiry = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _expiry: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// List realtime matches.
public struct Nakama_Api_ListMatchesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Limit the number of returned matches.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// Authoritative or relayed matches.
  public var authoritative: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _authoritative ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_authoritative = newValue}
  }
  /// Returns true if `authoritative` has been explicitly set.
  public var hasAuthoritative: Bool {return self._authoritative != nil}
  /// Clears the value of `authoritative`. Subsequent reads from it will return its default value.
  public mutating func clearAuthoritative() {self._authoritative = nil}

  /// Label filter.
  public var label: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _label ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  public var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  public mutating func clearLabel() {self._label = nil}

  /// Minimum user count.
  public var minSize: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _minSize ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_minSize = newValue}
  }
  /// Returns true if `minSize` has been explicitly set.
  public var hasMinSize: Bool {return self._minSize != nil}
  /// Clears the value of `minSize`. Subsequent reads from it will return its default value.
  public mutating func clearMinSize() {self._minSize = nil}

  /// Maximum user count.
  public var maxSize: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _maxSize ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_maxSize = newValue}
  }
  /// Returns true if `maxSize` has been explicitly set.
  public var hasMaxSize: Bool {return self._maxSize != nil}
  /// Clears the value of `maxSize`. Subsequent reads from it will return its default value.
  public mutating func clearMaxSize() {self._maxSize = nil}

  /// Arbitrary label query.
  public var query: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _query ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _authoritative: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _label: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _minSize: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _maxSize: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _query: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

/// Get a list of unexpired notifications.
public struct Nakama_Api_ListNotificationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of notifications to get. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// A cursor to page through notifications. May be cached by clients to get from point in time forwards.
  public var cacheableCursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

/// List publicly readable storage objects in a given collection.
public struct Nakama_Api_ListStorageObjectsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the user.
  public var userID: String = String()

  /// The collection which stores the object.
  public var collection: String = String()

  /// The number of storage objects to list. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// The cursor to page through results from.
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

/// List tournament records from a given tournament around the owner.
public struct Nakama_Api_ListTournamentRecordsAroundOwnerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the tournament to list for.
  public var tournamentID: String = String()

  /// Max number of records to return. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// The owner to retrieve records around.
  public var ownerID: String = String()

  /// Expiry in seconds (since epoch) to begin fetching records from.
  public var expiry: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _expiry ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_expiry = newValue}
  }
  /// Returns true if `expiry` has been explicitly set.
  public var hasExpiry: Bool {return self._expiry != nil}
  /// Clears the value of `expiry`. Subsequent reads from it will return its default value.
  public mutating func clearExpiry() {self._expiry = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _expiry: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// List tournament records from a given tournament.
public struct Nakama_Api_ListTournamentRecordsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the tournament to list for.
  public var tournamentID: String = String()

  /// One or more owners to retrieve records for.
  public var ownerIds: [String] = []

  /// Max number of records to return. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// A next or previous page cursor.
  public var cursor: String = String()

  /// Expiry in seconds (since epoch) to begin fetching records from.
  public var expiry: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _expiry ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_expiry = newValue}
  }
  /// Returns true if `expiry` has been explicitly set.
  public var hasExpiry: Bool {return self._expiry != nil}
  /// Clears the value of `expiry`. Subsequent reads from it will return its default value.
  public mutating func clearExpiry() {self._expiry = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _expiry: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// List active/upcoming tournaments based on given filters.
public struct Nakama_Api_ListTournamentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The start of the categories to include. Defaults to 0.
  public var categoryStart: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _categoryStart ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_categoryStart = newValue}
  }
  /// Returns true if `categoryStart` has been explicitly set.
  public var hasCategoryStart: Bool {return self._categoryStart != nil}
  /// Clears the value of `categoryStart`. Subsequent reads from it will return its default value.
  public mutating func clearCategoryStart() {self._categoryStart = nil}

  /// The end of the categories to include. Defaults to 128.
  public var categoryEnd: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _categoryEnd ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_categoryEnd = newValue}
  }
  /// Returns true if `categoryEnd` has been explicitly set.
  public var hasCategoryEnd: Bool {return self._categoryEnd != nil}
  /// Clears the value of `categoryEnd`. Subsequent reads from it will return its default value.
  public mutating func clearCategoryEnd() {self._categoryEnd = nil}

  /// The start time for tournaments. Defaults to epoch.
  public var startTime: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The end time for tournaments. Defaults to +1 year from current Unix time.
  public var endTime: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Max number of records to return. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// A next page cursor for listings (optional).
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _categoryStart: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _categoryEnd: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

/// List the groups a user is part of, and their relationship to each.
public struct Nakama_Api_ListUserGroupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the user.
  public var userID: String = String()

  /// Max number of records to return. Between 1 and 100.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  /// The user group state to list.
  public var state: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _state ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  /// An optional next page cursor.
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _state: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

/// Represents a realtime match.
public struct Nakama_Api_Match {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the match, can be used to join.
  public var matchID: String = String()

  /// True if it's an server-managed authoritative match, false otherwise.
  public var authoritative: Bool = false

  /// Match label, if any.
  public var label: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _label ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  public var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  public mutating func clearLabel() {self._label = nil}

  /// Current number of users in the match.
  public var size: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _label: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

/// A list of realtime matches.
public struct Nakama_Api_MatchList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A number of matches corresponding to a list operation.
  public var matches: [Nakama_Api_Match] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A notification in the server.
public struct Nakama_Api_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the Notification.
  public var id: String = String()

  /// Subject of the notification.
  public var subject: String = String()

  /// Content of the notification in JSON.
  public var content: String = String()

  /// Category code for this notification.
  public var code: Int32 = 0

  /// ID of the sender, if a user. Otherwise 'null'.
  public var senderID: String = String()

  /// The UNIX time when the notification was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// True if this notification was persisted to the database.
  public var persistent: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A collection of zero or more notifications.
public struct Nakama_Api_NotificationList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Collection of notifications.
  public var notifications: [Nakama_Api_Notification] = []

  /// Use this cursor to paginate notifications. Cache this to catch up to new notifications.
  public var cacheableCursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Promote a set of users in a group to the next role up.
public struct Nakama_Api_PromoteGroupUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to promote in.
  public var groupID: String = String()

  /// The users to promote.
  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Demote a set of users in a group to the next role down.
public struct Nakama_Api_DemoteGroupUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group ID to demote in.
  public var groupID: String = String()

  /// The users to demote.
  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Storage objects to get.
public struct Nakama_Api_ReadStorageObjectId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection which stores the object.
  public var collection: String = String()

  /// The key of the object within the collection.
  public var key: String = String()

  /// The user owner of the object.
  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Batch get storage objects.
public struct Nakama_Api_ReadStorageObjectsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Batch of storage objects.
  public var objectIds: [Nakama_Api_ReadStorageObjectId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Execute an Lua function on the server.
public struct Nakama_Api_Rpc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier of the function.
  public var id: String = String()

  /// The payload of the function which must be a JSON object.
  public var payload: String = String()

  /// The authentication key used when executed as a non-client HTTP request.
  public var httpKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A user's session used to authenticate messages.
public struct Nakama_Api_Session {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if the corresponding account was just created, false otherwise.
  public var created: Bool = false

  /// Authentication credentials.
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An object within the storage engine.
public struct Nakama_Api_StorageObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection which stores the object.
  public var collection: String = String()

  /// The key of the object within the collection.
  public var key: String = String()

  /// The user owner of the object.
  public var userID: String = String()

  /// The value of the object.
  public var value: String = String()

  /// The version hash of the object.
  public var version: String = String()

  /// The read access permissions for the object.
  public var permissionRead: Int32 = 0

  /// The write access permissions for the object.
  public var permissionWrite: Int32 = 0

  /// The UNIX time when the object was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// The UNIX time when the object was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A storage acknowledgement.
public struct Nakama_Api_StorageObjectAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection which stores the object.
  public var collection: String = String()

  /// The key of the object within the collection.
  public var key: String = String()

  /// The version hash of the object.
  public var version: String = String()

  /// The owner of the object.
  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Batch of acknowledgements for the storage object write.
public struct Nakama_Api_StorageObjectAcks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Batch of storage write acknowledgements.
  public var acks: [Nakama_Api_StorageObjectAck] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Batch of storage objects.
public struct Nakama_Api_StorageObjects {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The batch of storage objects.
  public var objects: [Nakama_Api_StorageObject] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// List of storage objects.
public struct Nakama_Api_StorageObjectList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of storage objects.
  public var objects: [Nakama_Api_StorageObject] = []

  /// The cursor for the next page of results, if any.
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A tournament on the server.
public struct Nakama_Api_Tournament {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the tournament.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The title for the tournament.
  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  /// The description of the tournament. May be blank.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The category of the tournament. e.g. "vip" could be category 1.
  public var category: UInt32 {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  /// ASC or DESC sort mode of scores in the tournament.
  public var sortOrder: UInt32 {
    get {return _storage._sortOrder}
    set {_uniqueStorage()._sortOrder = newValue}
  }

  /// The current number of players in the tournament.
  public var size: UInt32 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  /// The maximum number of players for the tournament.
  public var maxSize: UInt32 {
    get {return _storage._maxSize}
    set {_uniqueStorage()._maxSize = newValue}
  }

  /// The maximum score updates allowed per player for the current tournament.
  public var maxNumScore: UInt32 {
    get {return _storage._maxNumScore}
    set {_uniqueStorage()._maxNumScore = newValue}
  }

  /// True if the tournament is active and can enter. A computed value.
  public var canEnter: Bool {
    get {return _storage._canEnter}
    set {_uniqueStorage()._canEnter = newValue}
  }

  /// The UNIX time when the tournament stops being active until next reset. A computed value.
  public var endActive: UInt32 {
    get {return _storage._endActive}
    set {_uniqueStorage()._endActive = newValue}
  }

  /// The UNIX time when the tournament is next playable. A computed value.
  public var nextReset: UInt32 {
    get {return _storage._nextReset}
    set {_uniqueStorage()._nextReset = newValue}
  }

  /// Additional information stored as a JSON object.
  public var metadata: String {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  /// The UNIX time when the tournament was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// The UNIX time when the tournament will start.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// The UNIX time when the tournament will be stopped.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// Duration of the tournament in seconds.
  public var duration: UInt32 {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  /// The UNIX time when the tournament start being active. A computed value.
  public var startActive: UInt32 {
    get {return _storage._startActive}
    set {_uniqueStorage()._startActive = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of tournaments.
public struct Nakama_Api_TournamentList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of tournaments returned.
  public var tournaments: [Nakama_Api_Tournament] = []

  /// A pagination cursor (optional).
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A set of tournament records which may be part of a tournament records page or a batch of individual records.
public struct Nakama_Api_TournamentRecordList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of tournament records.
  public var records: [Nakama_Api_LeaderboardRecord] = []

  /// A batched set of tournament records belonging to specified owners.
  public var ownerRecords: [Nakama_Api_LeaderboardRecord] = []

  /// The cursor to send when retireving the next page (optional).
  public var nextCursor: String = String()

  /// The cursor to send when retrieving the previous page (optional).
  public var prevCursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Update a user's account details.
public struct Nakama_Api_UpdateAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The username of the user's account.
  public var username: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _username ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  public var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  public mutating func clearUsername() {self._username = nil}

  /// The display name of the user.
  public var displayName: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _displayName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_displayName = newValue}
  }
  /// Returns true if `displayName` has been explicitly set.
  public var hasDisplayName: Bool {return self._displayName != nil}
  /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
  public mutating func clearDisplayName() {self._displayName = nil}

  /// A URL for an avatar image.
  public var avatarURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _avatarURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_avatarURL = newValue}
  }
  /// Returns true if `avatarURL` has been explicitly set.
  public var hasAvatarURL: Bool {return self._avatarURL != nil}
  /// Clears the value of `avatarURL`. Subsequent reads from it will return its default value.
  public mutating func clearAvatarURL() {self._avatarURL = nil}

  /// The language expected to be a tag which follows the BCP-47 spec.
  public var langTag: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _langTag ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_langTag = newValue}
  }
  /// Returns true if `langTag` has been explicitly set.
  public var hasLangTag: Bool {return self._langTag != nil}
  /// Clears the value of `langTag`. Subsequent reads from it will return its default value.
  public mutating func clearLangTag() {self._langTag = nil}

  /// The location set by the user.
  public var location: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _location ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  /// The timezone set by the user.
  public var timezone: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _timezone ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_timezone = newValue}
  }
  /// Returns true if `timezone` has been explicitly set.
  public var hasTimezone: Bool {return self._timezone != nil}
  /// Clears the value of `timezone`. Subsequent reads from it will return its default value.
  public mutating func clearTimezone() {self._timezone = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _username: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _displayName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _avatarURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _langTag: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _location: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _timezone: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

/// Update fields in a given group.
public struct Nakama_Api_UpdateGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the group to update.
  public var groupID: String = String()

  /// Name.
  public var name: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _name ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// Description string.
  public var description_p: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _description_p ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  /// Lang tag.
  public var langTag: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _langTag ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_langTag = newValue}
  }
  /// Returns true if `langTag` has been explicitly set.
  public var hasLangTag: Bool {return self._langTag != nil}
  /// Clears the value of `langTag`. Subsequent reads from it will return its default value.
  public mutating func clearLangTag() {self._langTag = nil}

  /// Avatar URL.
  public var avatarURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _avatarURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_avatarURL = newValue}
  }
  /// Returns true if `avatarURL` has been explicitly set.
  public var hasAvatarURL: Bool {return self._avatarURL != nil}
  /// Clears the value of `avatarURL`. Subsequent reads from it will return its default value.
  public mutating func clearAvatarURL() {self._avatarURL = nil}

  /// Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
  public var `open`: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _open ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return self._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {self._open = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _description_p: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _langTag: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _avatarURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _open: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// A user in the server.
public struct Nakama_Api_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the user's account.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The username of the user's account.
  public var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  /// The display name of the user.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// A URL for an avatar image.
  public var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  /// The language expected to be a tag which follows the BCP-47 spec.
  public var langTag: String {
    get {return _storage._langTag}
    set {_uniqueStorage()._langTag = newValue}
  }

  /// The location set by the user.
  public var location: String {
    get {return _storage._location}
    set {_uniqueStorage()._location = newValue}
  }

  /// The timezone set by the user.
  public var timezone: String {
    get {return _storage._timezone}
    set {_uniqueStorage()._timezone = newValue}
  }

  /// Additional information stored as a JSON object.
  public var metadata: String {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  /// The Facebook id in the user's account.
  public var facebookID: String {
    get {return _storage._facebookID}
    set {_uniqueStorage()._facebookID = newValue}
  }

  /// The Google id in the user's account.
  public var googleID: String {
    get {return _storage._googleID}
    set {_uniqueStorage()._googleID = newValue}
  }

  /// The Apple Game Center in of the user's account.
  public var gamecenterID: String {
    get {return _storage._gamecenterID}
    set {_uniqueStorage()._gamecenterID = newValue}
  }

  /// The Steam id in the user's account.
  public var steamID: String {
    get {return _storage._steamID}
    set {_uniqueStorage()._steamID = newValue}
  }

  /// Indicates whether the user is currently online.
  public var online: Bool {
    get {return _storage._online}
    set {_uniqueStorage()._online = newValue}
  }

  /// Number of related edges to this user.
  public var edgeCount: Int32 {
    get {return _storage._edgeCount}
    set {_uniqueStorage()._edgeCount = newValue}
  }

  /// The UNIX time when the user was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// The UNIX time when the user was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// The Facebook Instant Game ID in the user's account.
  public var facebookInstantGameID: String {
    get {return _storage._facebookInstantGameID}
    set {_uniqueStorage()._facebookInstantGameID = newValue}
  }

  /// The Apple Sign In ID in the user's account.
  public var appleID: String {
    get {return _storage._appleID}
    set {_uniqueStorage()._appleID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A list of groups belonging to a user, along with the user's role in each group.
public struct Nakama_Api_UserGroupList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Group-role pairs for a user.
  public var userGroups: [Nakama_Api_UserGroupList.UserGroup] = []

  /// Cursor for the next page of results, if any.
  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single group-role pair.
  public struct UserGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Group.
    public var group: Nakama_Api_Group {
      get {return _group ?? Nakama_Api_Group()}
      set {_group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    public var hasGroup: Bool {return self._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    public mutating func clearGroup() {self._group = nil}

    /// The user's relationship to the group.
    public var state: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _state ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_state = newValue}
    }
    /// Returns true if `state` has been explicitly set.
    public var hasState: Bool {return self._state != nil}
    /// Clears the value of `state`. Subsequent reads from it will return its default value.
    public mutating func clearState() {self._state = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The group role status.
    public enum State: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The user is a superadmin with full control of the group.
      case superadmin // = 0

      /// The user is an admin with additional privileges.
      case admin // = 1

      /// The user is a regular member.
      case member // = 2

      /// The user has requested to join the group
      case joinRequest // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .superadmin
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .superadmin
        case 1: self = .admin
        case 2: self = .member
        case 3: self = .joinRequest
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .superadmin: return 0
        case .admin: return 1
        case .member: return 2
        case .joinRequest: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _group: Nakama_Api_Group? = nil
    fileprivate var _state: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  }

  public init() {}
}

#if swift(>=4.2)

extension Nakama_Api_UserGroupList.UserGroup.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Nakama_Api_UserGroupList.UserGroup.State] = [
    .superadmin,
    .admin,
    .member,
    .joinRequest,
  ]
}

#endif  // swift(>=4.2)

/// A collection of zero or more users.
public struct Nakama_Api_Users {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The User objects.
  public var users: [Nakama_Api_User] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request to submit a score to a leaderboard.
public struct Nakama_Api_WriteLeaderboardRecordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the leaderboard to write to.
  public var leaderboardID: String = String()

  /// Record input.
  public var record: Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite {
    get {return _record ?? Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite()}
    set {_record = newValue}
  }
  /// Returns true if `record` has been explicitly set.
  public var hasRecord: Bool {return self._record != nil}
  /// Clears the value of `record`. Subsequent reads from it will return its default value.
  public mutating func clearRecord() {self._record = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Record values to write.
  public struct LeaderboardRecordWrite {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The score value to submit.
    public var score: Int64 = 0

    /// An optional secondary value.
    public var subscore: Int64 = 0

    /// Optional record metadata.
    public var metadata: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _record: Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite? = nil
}

/// The object to store.
public struct Nakama_Api_WriteStorageObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection to store the object.
  public var collection: String = String()

  /// The key for the object within the collection.
  public var key: String = String()

  /// The value of the object.
  public var value: String = String()

  /// The version hash of the object to check. Possible values are: ["", "*", "#hash#"].
  public var version: String = String()

  /// The read access permissions for the object.
  public var permissionRead: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _permissionRead ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_permissionRead = newValue}
  }
  /// Returns true if `permissionRead` has been explicitly set.
  public var hasPermissionRead: Bool {return self._permissionRead != nil}
  /// Clears the value of `permissionRead`. Subsequent reads from it will return its default value.
  public mutating func clearPermissionRead() {self._permissionRead = nil}

  /// The write access permissions for the object.
  public var permissionWrite: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _permissionWrite ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_permissionWrite = newValue}
  }
  /// Returns true if `permissionWrite` has been explicitly set.
  public var hasPermissionWrite: Bool {return self._permissionWrite != nil}
  /// Clears the value of `permissionWrite`. Subsequent reads from it will return its default value.
  public mutating func clearPermissionWrite() {self._permissionWrite = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _permissionRead: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _permissionWrite: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

/// Write objects to the storage engine.
public struct Nakama_Api_WriteStorageObjectsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The objects to store on the server.
  public var objects: [Nakama_Api_WriteStorageObject] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request to submit a score to a tournament.
public struct Nakama_Api_WriteTournamentRecordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The tournament ID to write the record for.
  public var tournamentID: String = String()

  /// Record input.
  public var record: Nakama_Api_WriteTournamentRecordRequest.TournamentRecordWrite {
    get {return _record ?? Nakama_Api_WriteTournamentRecordRequest.TournamentRecordWrite()}
    set {_record = newValue}
  }
  /// Returns true if `record` has been explicitly set.
  public var hasRecord: Bool {return self._record != nil}
  /// Clears the value of `record`. Subsequent reads from it will return its default value.
  public mutating func clearRecord() {self._record = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Record values to write.
  public struct TournamentRecordWrite {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The score value to submit.
    public var score: Int64 = 0

    /// An optional secondary value.
    public var subscore: Int64 = 0

    /// A JSON object of additional properties (optional).
    public var metadata: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _record: Nakama_Api_WriteTournamentRecordRequest.TournamentRecordWrite? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nakama.api"

extension Nakama_Api_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Account"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "wallet"),
    3: .same(proto: "email"),
    4: .same(proto: "devices"),
    5: .standard(proto: "custom_id"),
    6: .standard(proto: "verify_time"),
    7: .standard(proto: "disable_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.wallet) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.customID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._verifyTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._disableTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.wallet.isEmpty {
      try visitor.visitSingularStringField(value: self.wallet, fieldNumber: 2)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 3)
    }
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 4)
    }
    if !self.customID.isEmpty {
      try visitor.visitSingularStringField(value: self.customID, fieldNumber: 5)
    }
    if let v = self._verifyTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._disableTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_Account, rhs: Nakama_Api_Account) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.wallet != rhs.wallet {return false}
    if lhs.email != rhs.email {return false}
    if lhs.devices != rhs.devices {return false}
    if lhs.customID != rhs.customID {return false}
    if lhs._verifyTime != rhs._verifyTime {return false}
    if lhs._disableTime != rhs._disableTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountApple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountApple"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "vars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.vars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.vars.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.vars, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AccountApple, rhs: Nakama_Api_AccountApple) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.vars != rhs.vars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountCustom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountCustom"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "vars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.vars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.vars.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.vars, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AccountCustom, rhs: Nakama_Api_AccountCustom) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.vars != rhs.vars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountDevice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "vars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.vars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.vars.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.vars, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AccountDevice, rhs: Nakama_Api_AccountDevice) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.vars != rhs.vars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountEmail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountEmail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
    3: .same(proto: "vars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.vars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.vars.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.vars, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AccountEmail, rhs: Nakama_Api_AccountEmail) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.password != rhs.password {return false}
    if lhs.vars != rhs.vars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountFacebook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountFacebook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "vars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.vars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.vars.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.vars, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AccountFacebook, rhs: Nakama_Api_AccountFacebook) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.vars != rhs.vars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountFacebookInstantGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountFacebookInstantGame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_player_info"),
    2: .same(proto: "vars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signedPlayerInfo) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.vars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedPlayerInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.signedPlayerInfo, fieldNumber: 1)
    }
    if !self.vars.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.vars, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AccountFacebookInstantGame, rhs: Nakama_Api_AccountFacebookInstantGame) -> Bool {
    if lhs.signedPlayerInfo != rhs.signedPlayerInfo {return false}
    if lhs.vars != rhs.vars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountGameCenter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountGameCenter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "player_id"),
    2: .standard(proto: "bundle_id"),
    3: .standard(proto: "timestamp_seconds"),
    4: .same(proto: "salt"),
    5: .same(proto: "signature"),
    6: .standard(proto: "public_key_url"),
    7: .same(proto: "vars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.playerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampSeconds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.publicKeyURL) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.vars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.playerID.isEmpty {
      try visitor.visitSingularStringField(value: self.playerID, fieldNumber: 1)
    }
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 2)
    }
    if self.timestampSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampSeconds, fieldNumber: 3)
    }
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 4)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 5)
    }
    if !self.publicKeyURL.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKeyURL, fieldNumber: 6)
    }
    if !self.vars.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.vars, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AccountGameCenter, rhs: Nakama_Api_AccountGameCenter) -> Bool {
    if lhs.playerID != rhs.playerID {return false}
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.timestampSeconds != rhs.timestampSeconds {return false}
    if lhs.salt != rhs.salt {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.publicKeyURL != rhs.publicKeyURL {return false}
    if lhs.vars != rhs.vars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountGoogle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountGoogle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "vars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.vars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.vars.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.vars, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AccountGoogle, rhs: Nakama_Api_AccountGoogle) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.vars != rhs.vars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AccountSteam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountSteam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "vars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.vars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.vars.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.vars, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AccountSteam, rhs: Nakama_Api_AccountSteam) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.vars != rhs.vars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AddFriendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddFriendsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "usernames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.usernames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    if !self.usernames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usernames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AddFriendsRequest, rhs: Nakama_Api_AddFriendsRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.usernames != rhs.usernames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AddGroupUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddGroupUsersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AddGroupUsersRequest, rhs: Nakama_Api_AddGroupUsersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateAppleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateAppleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._create) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._create {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AuthenticateAppleRequest, rhs: Nakama_Api_AuthenticateAppleRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._create != rhs._create {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateCustomRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateCustomRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._create) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._create {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AuthenticateCustomRequest, rhs: Nakama_Api_AuthenticateCustomRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._create != rhs._create {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateDeviceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._create) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._create {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AuthenticateDeviceRequest, rhs: Nakama_Api_AuthenticateDeviceRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._create != rhs._create {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateEmailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateEmailRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._create) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._create {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AuthenticateEmailRequest, rhs: Nakama_Api_AuthenticateEmailRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._create != rhs._create {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateFacebookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateFacebookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
    4: .same(proto: "sync"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._create) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._sync) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._create {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    if let v = self._sync {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AuthenticateFacebookRequest, rhs: Nakama_Api_AuthenticateFacebookRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._create != rhs._create {return false}
    if lhs.username != rhs.username {return false}
    if lhs._sync != rhs._sync {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateFacebookInstantGameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateFacebookInstantGameRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._create) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._create {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AuthenticateFacebookInstantGameRequest, rhs: Nakama_Api_AuthenticateFacebookInstantGameRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._create != rhs._create {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateGameCenterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateGameCenterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._create) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._create {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AuthenticateGameCenterRequest, rhs: Nakama_Api_AuthenticateGameCenterRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._create != rhs._create {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateGoogleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateGoogleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._create) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._create {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AuthenticateGoogleRequest, rhs: Nakama_Api_AuthenticateGoogleRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._create != rhs._create {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_AuthenticateSteamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateSteamRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "create"),
    3: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._create) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._create {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_AuthenticateSteamRequest, rhs: Nakama_Api_AuthenticateSteamRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._create != rhs._create {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_BanGroupUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BanGroupUsersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_BanGroupUsersRequest, rhs: Nakama_Api_BanGroupUsersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_BlockFriendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockFriendsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "usernames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.usernames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    if !self.usernames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usernames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_BlockFriendsRequest, rhs: Nakama_Api_BlockFriendsRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.usernames != rhs.usernames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ChannelMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "code"),
    4: .standard(proto: "sender_id"),
    5: .same(proto: "username"),
    6: .same(proto: "content"),
    7: .standard(proto: "create_time"),
    8: .standard(proto: "update_time"),
    9: .same(proto: "persistent"),
    10: .standard(proto: "room_name"),
    11: .standard(proto: "group_id"),
    12: .standard(proto: "user_id_one"),
    13: .standard(proto: "user_id_two"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._code) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.senderID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._persistent) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.roomName) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.userIDOne) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.userIDTwo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 2)
    }
    if let v = self._code {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.senderID.isEmpty {
      try visitor.visitSingularStringField(value: self.senderID, fieldNumber: 4)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 5)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 6)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._persistent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if !self.roomName.isEmpty {
      try visitor.visitSingularStringField(value: self.roomName, fieldNumber: 10)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 11)
    }
    if !self.userIDOne.isEmpty {
      try visitor.visitSingularStringField(value: self.userIDOne, fieldNumber: 12)
    }
    if !self.userIDTwo.isEmpty {
      try visitor.visitSingularStringField(value: self.userIDTwo, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ChannelMessage, rhs: Nakama_Api_ChannelMessage) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._code != rhs._code {return false}
    if lhs.senderID != rhs.senderID {return false}
    if lhs.username != rhs.username {return false}
    if lhs.content != rhs.content {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs._persistent != rhs._persistent {return false}
    if lhs.roomName != rhs.roomName {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIDOne != rhs.userIDOne {return false}
    if lhs.userIDTwo != rhs.userIDTwo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ChannelMessageList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelMessageList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "next_cursor"),
    3: .standard(proto: "prev_cursor"),
    4: .standard(proto: "cacheable_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextCursor) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.prevCursor) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cacheableCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if !self.nextCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.nextCursor, fieldNumber: 2)
    }
    if !self.prevCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.prevCursor, fieldNumber: 3)
    }
    if !self.cacheableCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cacheableCursor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ChannelMessageList, rhs: Nakama_Api_ChannelMessageList) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.nextCursor != rhs.nextCursor {return false}
    if lhs.prevCursor != rhs.prevCursor {return false}
    if lhs.cacheableCursor != rhs.cacheableCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_CreateGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "lang_tag"),
    4: .standard(proto: "avatar_url"),
    5: .same(proto: "open"),
    6: .standard(proto: "max_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.langTag) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.`open`) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.maxCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.langTag.isEmpty {
      try visitor.visitSingularStringField(value: self.langTag, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if self.`open` != false {
      try visitor.visitSingularBoolField(value: self.`open`, fieldNumber: 5)
    }
    if self.maxCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_CreateGroupRequest, rhs: Nakama_Api_CreateGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.langTag != rhs.langTag {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.`open` != rhs.`open` {return false}
    if lhs.maxCount != rhs.maxCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteFriendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFriendsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "usernames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.usernames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    if !self.usernames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usernames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_DeleteFriendsRequest, rhs: Nakama_Api_DeleteFriendsRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.usernames != rhs.usernames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_DeleteGroupRequest, rhs: Nakama_Api_DeleteGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteLeaderboardRecordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteLeaderboardRecordRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.leaderboardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaderboardID.isEmpty {
      try visitor.visitSingularStringField(value: self.leaderboardID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_DeleteLeaderboardRecordRequest, rhs: Nakama_Api_DeleteLeaderboardRecordRequest) -> Bool {
    if lhs.leaderboardID != rhs.leaderboardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteNotificationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNotificationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_DeleteNotificationsRequest, rhs: Nakama_Api_DeleteNotificationsRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteStorageObjectId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStorageObjectId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
    2: .same(proto: "key"),
    3: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collection) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_DeleteStorageObjectId, rhs: Nakama_Api_DeleteStorageObjectId) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.key != rhs.key {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DeleteStorageObjectsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteStorageObjectsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.objectIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_DeleteStorageObjectsRequest, rhs: Nakama_Api_DeleteStorageObjectsRequest) -> Bool {
    if lhs.objectIds != rhs.objectIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "properties"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "external"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.properties) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.external) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.properties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.properties, fieldNumber: 2)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.external != false {
      try visitor.visitSingularBoolField(value: self.external, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_Event, rhs: Nakama_Api_Event) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.external != rhs.external {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Friend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Friend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "state"),
    3: .standard(proto: "update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_Friend, rhs: Nakama_Api_Friend) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs._state != rhs._state {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Friend.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FRIEND"),
    1: .same(proto: "INVITE_SENT"),
    2: .same(proto: "INVITE_RECEIVED"),
    3: .same(proto: "BLOCKED"),
  ]
}

extension Nakama_Api_FriendList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FriendList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friends"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.friends) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.friends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.friends, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_FriendList, rhs: Nakama_Api_FriendList) -> Bool {
    if lhs.friends != rhs.friends {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_GetUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUsersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "usernames"),
    3: .standard(proto: "facebook_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.usernames) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.facebookIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    if !self.usernames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usernames, fieldNumber: 2)
    }
    if !self.facebookIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.facebookIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_GetUsersRequest, rhs: Nakama_Api_GetUsersRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.usernames != rhs.usernames {return false}
    if lhs.facebookIds != rhs.facebookIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Group"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "creator_id"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .standard(proto: "lang_tag"),
    6: .same(proto: "metadata"),
    7: .standard(proto: "avatar_url"),
    8: .same(proto: "open"),
    9: .standard(proto: "edge_count"),
    10: .standard(proto: "max_count"),
    11: .standard(proto: "create_time"),
    12: .standard(proto: "update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.creatorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.langTag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.edgeCount) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.maxCount) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.creatorID.isEmpty {
      try visitor.visitSingularStringField(value: self.creatorID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.langTag.isEmpty {
      try visitor.visitSingularStringField(value: self.langTag, fieldNumber: 5)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 6)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 7)
    }
    if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if self.edgeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.edgeCount, fieldNumber: 9)
    }
    if self.maxCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCount, fieldNumber: 10)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_Group, rhs: Nakama_Api_Group) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.creatorID != rhs.creatorID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.langTag != rhs.langTag {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs._open != rhs._open {return false}
    if lhs.edgeCount != rhs.edgeCount {return false}
    if lhs.maxCount != rhs.maxCount {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_GroupList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_GroupList, rhs: Nakama_Api_GroupList) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_GroupUserList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupUserList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_users"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupUsers) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupUsers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupUsers, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_GroupUserList, rhs: Nakama_Api_GroupUserList) -> Bool {
    if lhs.groupUsers != rhs.groupUsers {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_GroupUserList.GroupUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Nakama_Api_GroupUserList.protoMessageName + ".GroupUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_GroupUserList.GroupUser, rhs: Nakama_Api_GroupUserList.GroupUser) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_GroupUserList.GroupUser.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUPERADMIN"),
    1: .same(proto: "ADMIN"),
    2: .same(proto: "MEMBER"),
    3: .same(proto: "JOIN_REQUEST"),
  ]
}

extension Nakama_Api_ImportFacebookFriendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportFacebookFriendsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "reset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._reset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._reset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ImportFacebookFriendsRequest, rhs: Nakama_Api_ImportFacebookFriendsRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._reset != rhs._reset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_JoinGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_JoinGroupRequest, rhs: Nakama_Api_JoinGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_JoinTournamentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinTournamentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tournament_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tournamentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tournamentID.isEmpty {
      try visitor.visitSingularStringField(value: self.tournamentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_JoinTournamentRequest, rhs: Nakama_Api_JoinTournamentRequest) -> Bool {
    if lhs.tournamentID != rhs.tournamentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_KickGroupUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KickGroupUsersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_KickGroupUsersRequest, rhs: Nakama_Api_KickGroupUsersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_LeaderboardRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaderboardRecord"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
    2: .standard(proto: "owner_id"),
    3: .same(proto: "username"),
    4: .same(proto: "score"),
    5: .same(proto: "subscore"),
    6: .standard(proto: "num_score"),
    7: .same(proto: "metadata"),
    8: .standard(proto: "create_time"),
    9: .standard(proto: "update_time"),
    10: .standard(proto: "expiry_time"),
    11: .same(proto: "rank"),
    12: .standard(proto: "max_num_score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.leaderboardID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._username) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.score) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.subscore) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.numScore) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._expiryTime) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.rank) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.maxNumScore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaderboardID.isEmpty {
      try visitor.visitSingularStringField(value: self.leaderboardID, fieldNumber: 1)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 2)
    }
    if let v = self._username {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.score != 0 {
      try visitor.visitSingularInt64Field(value: self.score, fieldNumber: 4)
    }
    if self.subscore != 0 {
      try visitor.visitSingularInt64Field(value: self.subscore, fieldNumber: 5)
    }
    if self.numScore != 0 {
      try visitor.visitSingularInt32Field(value: self.numScore, fieldNumber: 6)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 7)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._expiryTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if self.rank != 0 {
      try visitor.visitSingularInt64Field(value: self.rank, fieldNumber: 11)
    }
    if self.maxNumScore != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxNumScore, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_LeaderboardRecord, rhs: Nakama_Api_LeaderboardRecord) -> Bool {
    if lhs.leaderboardID != rhs.leaderboardID {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs._username != rhs._username {return false}
    if lhs.score != rhs.score {return false}
    if lhs.subscore != rhs.subscore {return false}
    if lhs.numScore != rhs.numScore {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs._expiryTime != rhs._expiryTime {return false}
    if lhs.rank != rhs.rank {return false}
    if lhs.maxNumScore != rhs.maxNumScore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_LeaderboardRecordList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaderboardRecordList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "records"),
    2: .standard(proto: "owner_records"),
    3: .standard(proto: "next_cursor"),
    4: .standard(proto: "prev_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ownerRecords) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextCursor) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prevCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 1)
    }
    if !self.ownerRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ownerRecords, fieldNumber: 2)
    }
    if !self.nextCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.nextCursor, fieldNumber: 3)
    }
    if !self.prevCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.prevCursor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_LeaderboardRecordList, rhs: Nakama_Api_LeaderboardRecordList) -> Bool {
    if lhs.records != rhs.records {return false}
    if lhs.ownerRecords != rhs.ownerRecords {return false}
    if lhs.nextCursor != rhs.nextCursor {return false}
    if lhs.prevCursor != rhs.prevCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_LeaveGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LeaveGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_LeaveGroupRequest, rhs: Nakama_Api_LeaveGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_LinkFacebookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LinkFacebookRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    4: .same(proto: "sync"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._sync) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._sync {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_LinkFacebookRequest, rhs: Nakama_Api_LinkFacebookRequest) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._sync != rhs._sync {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListChannelMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListChannelMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "limit"),
    3: .same(proto: "forward"),
    4: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._forward) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._forward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListChannelMessagesRequest, rhs: Nakama_Api_ListChannelMessagesRequest) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs._forward != rhs._forward {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListFriendsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFriendsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .same(proto: "state"),
    3: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListFriendsRequest, rhs: Nakama_Api_ListFriendsRequest) -> Bool {
    if lhs._limit != rhs._limit {return false}
    if lhs._state != rhs._state {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGroupsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "cursor"),
    3: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListGroupsRequest, rhs: Nakama_Api_ListGroupsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListGroupUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGroupUsersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "limit"),
    3: .same(proto: "state"),
    4: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListGroupUsersRequest, rhs: Nakama_Api_ListGroupUsersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs._state != rhs._state {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListLeaderboardRecordsAroundOwnerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListLeaderboardRecordsAroundOwnerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
    2: .same(proto: "limit"),
    3: .standard(proto: "owner_id"),
    4: .same(proto: "expiry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.leaderboardID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expiry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaderboardID.isEmpty {
      try visitor.visitSingularStringField(value: self.leaderboardID, fieldNumber: 1)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 3)
    }
    if let v = self._expiry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListLeaderboardRecordsAroundOwnerRequest, rhs: Nakama_Api_ListLeaderboardRecordsAroundOwnerRequest) -> Bool {
    if lhs.leaderboardID != rhs.leaderboardID {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs._expiry != rhs._expiry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListLeaderboardRecordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListLeaderboardRecordsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
    2: .standard(proto: "owner_ids"),
    3: .same(proto: "limit"),
    4: .same(proto: "cursor"),
    5: .same(proto: "expiry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.leaderboardID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ownerIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaderboardID.isEmpty {
      try visitor.visitSingularStringField(value: self.leaderboardID, fieldNumber: 1)
    }
    if !self.ownerIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ownerIds, fieldNumber: 2)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 4)
    }
    if let v = self._expiry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListLeaderboardRecordsRequest, rhs: Nakama_Api_ListLeaderboardRecordsRequest) -> Bool {
    if lhs.leaderboardID != rhs.leaderboardID {return false}
    if lhs.ownerIds != rhs.ownerIds {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs._expiry != rhs._expiry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListMatchesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListMatchesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .same(proto: "authoritative"),
    3: .same(proto: "label"),
    4: .standard(proto: "min_size"),
    5: .standard(proto: "max_size"),
    6: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authoritative) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._label) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._minSize) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._maxSize) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._authoritative {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._label {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._minSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._maxSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListMatchesRequest, rhs: Nakama_Api_ListMatchesRequest) -> Bool {
    if lhs._limit != rhs._limit {return false}
    if lhs._authoritative != rhs._authoritative {return false}
    if lhs._label != rhs._label {return false}
    if lhs._minSize != rhs._minSize {return false}
    if lhs._maxSize != rhs._maxSize {return false}
    if lhs._query != rhs._query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListNotificationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNotificationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .standard(proto: "cacheable_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cacheableCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.cacheableCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cacheableCursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListNotificationsRequest, rhs: Nakama_Api_ListNotificationsRequest) -> Bool {
    if lhs._limit != rhs._limit {return false}
    if lhs.cacheableCursor != rhs.cacheableCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListStorageObjectsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListStorageObjectsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "collection"),
    3: .same(proto: "limit"),
    4: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.collection) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 2)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListStorageObjectsRequest, rhs: Nakama_Api_ListStorageObjectsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.collection != rhs.collection {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListTournamentRecordsAroundOwnerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTournamentRecordsAroundOwnerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tournament_id"),
    2: .same(proto: "limit"),
    3: .standard(proto: "owner_id"),
    4: .same(proto: "expiry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tournamentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expiry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tournamentID.isEmpty {
      try visitor.visitSingularStringField(value: self.tournamentID, fieldNumber: 1)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 3)
    }
    if let v = self._expiry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListTournamentRecordsAroundOwnerRequest, rhs: Nakama_Api_ListTournamentRecordsAroundOwnerRequest) -> Bool {
    if lhs.tournamentID != rhs.tournamentID {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs._expiry != rhs._expiry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListTournamentRecordsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTournamentRecordsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tournament_id"),
    2: .standard(proto: "owner_ids"),
    3: .same(proto: "limit"),
    4: .same(proto: "cursor"),
    5: .same(proto: "expiry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tournamentID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ownerIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tournamentID.isEmpty {
      try visitor.visitSingularStringField(value: self.tournamentID, fieldNumber: 1)
    }
    if !self.ownerIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ownerIds, fieldNumber: 2)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 4)
    }
    if let v = self._expiry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListTournamentRecordsRequest, rhs: Nakama_Api_ListTournamentRecordsRequest) -> Bool {
    if lhs.tournamentID != rhs.tournamentID {return false}
    if lhs.ownerIds != rhs.ownerIds {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs._expiry != rhs._expiry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListTournamentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTournamentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "category_start"),
    2: .standard(proto: "category_end"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "end_time"),
    6: .same(proto: "limit"),
    8: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._categoryStart) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._categoryEnd) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._categoryStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._categoryEnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListTournamentsRequest, rhs: Nakama_Api_ListTournamentsRequest) -> Bool {
    if lhs._categoryStart != rhs._categoryStart {return false}
    if lhs._categoryEnd != rhs._categoryEnd {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ListUserGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListUserGroupsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "limit"),
    3: .same(proto: "state"),
    4: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ListUserGroupsRequest, rhs: Nakama_Api_ListUserGroupsRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs._state != rhs._state {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Match: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Match"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_id"),
    2: .same(proto: "authoritative"),
    3: .same(proto: "label"),
    4: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.matchID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.authoritative) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._label) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchID.isEmpty {
      try visitor.visitSingularStringField(value: self.matchID, fieldNumber: 1)
    }
    if self.authoritative != false {
      try visitor.visitSingularBoolField(value: self.authoritative, fieldNumber: 2)
    }
    if let v = self._label {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_Match, rhs: Nakama_Api_Match) -> Bool {
    if lhs.matchID != rhs.matchID {return false}
    if lhs.authoritative != rhs.authoritative {return false}
    if lhs._label != rhs._label {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_MatchList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.matches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matches, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_MatchList, rhs: Nakama_Api_MatchList) -> Bool {
    if lhs.matches != rhs.matches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "subject"),
    3: .same(proto: "content"),
    4: .same(proto: "code"),
    5: .standard(proto: "sender_id"),
    6: .standard(proto: "create_time"),
    7: .same(proto: "persistent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.senderID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.persistent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 4)
    }
    if !self.senderID.isEmpty {
      try visitor.visitSingularStringField(value: self.senderID, fieldNumber: 5)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.persistent != false {
      try visitor.visitSingularBoolField(value: self.persistent, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_Notification, rhs: Nakama_Api_Notification) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.content != rhs.content {return false}
    if lhs.code != rhs.code {return false}
    if lhs.senderID != rhs.senderID {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.persistent != rhs.persistent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_NotificationList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifications"),
    2: .standard(proto: "cacheable_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notifications) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cacheableCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notifications, fieldNumber: 1)
    }
    if !self.cacheableCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cacheableCursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_NotificationList, rhs: Nakama_Api_NotificationList) -> Bool {
    if lhs.notifications != rhs.notifications {return false}
    if lhs.cacheableCursor != rhs.cacheableCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_PromoteGroupUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromoteGroupUsersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_PromoteGroupUsersRequest, rhs: Nakama_Api_PromoteGroupUsersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_DemoteGroupUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DemoteGroupUsersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "user_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_DemoteGroupUsersRequest, rhs: Nakama_Api_DemoteGroupUsersRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ReadStorageObjectId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadStorageObjectId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
    2: .same(proto: "key"),
    3: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collection) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ReadStorageObjectId, rhs: Nakama_Api_ReadStorageObjectId) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.key != rhs.key {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_ReadStorageObjectsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadStorageObjectsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.objectIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_ReadStorageObjectsRequest, rhs: Nakama_Api_ReadStorageObjectsRequest) -> Bool {
    if lhs.objectIds != rhs.objectIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Rpc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rpc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "payload"),
    3: .standard(proto: "http_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.httpKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 2)
    }
    if !self.httpKey.isEmpty {
      try visitor.visitSingularStringField(value: self.httpKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_Rpc, rhs: Nakama_Api_Rpc) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.httpKey != rhs.httpKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Session"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "created"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.created) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.created != false {
      try visitor.visitSingularBoolField(value: self.created, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_Session, rhs: Nakama_Api_Session) -> Bool {
    if lhs.created != rhs.created {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_StorageObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StorageObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
    2: .same(proto: "key"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "value"),
    5: .same(proto: "version"),
    6: .standard(proto: "permission_read"),
    7: .standard(proto: "permission_write"),
    8: .standard(proto: "create_time"),
    9: .standard(proto: "update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collection) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.permissionRead) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.permissionWrite) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 4)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 5)
    }
    if self.permissionRead != 0 {
      try visitor.visitSingularInt32Field(value: self.permissionRead, fieldNumber: 6)
    }
    if self.permissionWrite != 0 {
      try visitor.visitSingularInt32Field(value: self.permissionWrite, fieldNumber: 7)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_StorageObject, rhs: Nakama_Api_StorageObject) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.key != rhs.key {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.value != rhs.value {return false}
    if lhs.version != rhs.version {return false}
    if lhs.permissionRead != rhs.permissionRead {return false}
    if lhs.permissionWrite != rhs.permissionWrite {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_StorageObjectAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StorageObjectAck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
    2: .same(proto: "key"),
    3: .same(proto: "version"),
    4: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collection) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_StorageObjectAck, rhs: Nakama_Api_StorageObjectAck) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.key != rhs.key {return false}
    if lhs.version != rhs.version {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_StorageObjectAcks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StorageObjectAcks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "acks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.acks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.acks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.acks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_StorageObjectAcks, rhs: Nakama_Api_StorageObjectAcks) -> Bool {
    if lhs.acks != rhs.acks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_StorageObjects: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StorageObjects"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objects"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.objects) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_StorageObjects, rhs: Nakama_Api_StorageObjects) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_StorageObjectList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StorageObjectList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objects"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.objects) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_StorageObjectList, rhs: Nakama_Api_StorageObjectList) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_Tournament: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tournament"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .same(proto: "category"),
    5: .standard(proto: "sort_order"),
    6: .same(proto: "size"),
    7: .standard(proto: "max_size"),
    8: .standard(proto: "max_num_score"),
    9: .standard(proto: "can_enter"),
    10: .standard(proto: "end_active"),
    11: .standard(proto: "next_reset"),
    12: .same(proto: "metadata"),
    13: .standard(proto: "create_time"),
    14: .standard(proto: "start_time"),
    15: .standard(proto: "end_time"),
    16: .same(proto: "duration"),
    17: .standard(proto: "start_active"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _title: String = String()
    var _description_p: String = String()
    var _category: UInt32 = 0
    var _sortOrder: UInt32 = 0
    var _size: UInt32 = 0
    var _maxSize: UInt32 = 0
    var _maxNumScore: UInt32 = 0
    var _canEnter: Bool = false
    var _endActive: UInt32 = 0
    var _nextReset: UInt32 = 0
    var _metadata: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _duration: UInt32 = 0
    var _startActive: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _title = source._title
      _description_p = source._description_p
      _category = source._category
      _sortOrder = source._sortOrder
      _size = source._size
      _maxSize = source._maxSize
      _maxNumScore = source._maxNumScore
      _canEnter = source._canEnter
      _endActive = source._endActive
      _nextReset = source._nextReset
      _metadata = source._metadata
      _createTime = source._createTime
      _startTime = source._startTime
      _endTime = source._endTime
      _duration = source._duration
      _startActive = source._startActive
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._category) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._sortOrder) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._size) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxSize) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxNumScore) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._canEnter) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._endActive) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._nextReset) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._metadata) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._duration) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._startActive) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if _storage._category != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._category, fieldNumber: 4)
      }
      if _storage._sortOrder != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sortOrder, fieldNumber: 5)
      }
      if _storage._size != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._size, fieldNumber: 6)
      }
      if _storage._maxSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxSize, fieldNumber: 7)
      }
      if _storage._maxNumScore != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxNumScore, fieldNumber: 8)
      }
      if _storage._canEnter != false {
        try visitor.visitSingularBoolField(value: _storage._canEnter, fieldNumber: 9)
      }
      if _storage._endActive != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._endActive, fieldNumber: 10)
      }
      if _storage._nextReset != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._nextReset, fieldNumber: 11)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadata, fieldNumber: 12)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._duration, fieldNumber: 16)
      }
      if _storage._startActive != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._startActive, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_Tournament, rhs: Nakama_Api_Tournament) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._sortOrder != rhs_storage._sortOrder {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._maxSize != rhs_storage._maxSize {return false}
        if _storage._maxNumScore != rhs_storage._maxNumScore {return false}
        if _storage._canEnter != rhs_storage._canEnter {return false}
        if _storage._endActive != rhs_storage._endActive {return false}
        if _storage._nextReset != rhs_storage._nextReset {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._startActive != rhs_storage._startActive {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_TournamentList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TournamentList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tournaments"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tournaments) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tournaments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tournaments, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_TournamentList, rhs: Nakama_Api_TournamentList) -> Bool {
    if lhs.tournaments != rhs.tournaments {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_TournamentRecordList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TournamentRecordList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "records"),
    2: .standard(proto: "owner_records"),
    3: .standard(proto: "next_cursor"),
    4: .standard(proto: "prev_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ownerRecords) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextCursor) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prevCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 1)
    }
    if !self.ownerRecords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ownerRecords, fieldNumber: 2)
    }
    if !self.nextCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.nextCursor, fieldNumber: 3)
    }
    if !self.prevCursor.isEmpty {
      try visitor.visitSingularStringField(value: self.prevCursor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_TournamentRecordList, rhs: Nakama_Api_TournamentRecordList) -> Bool {
    if lhs.records != rhs.records {return false}
    if lhs.ownerRecords != rhs.ownerRecords {return false}
    if lhs.nextCursor != rhs.nextCursor {return false}
    if lhs.prevCursor != rhs.prevCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_UpdateAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "avatar_url"),
    4: .standard(proto: "lang_tag"),
    5: .same(proto: "location"),
    6: .same(proto: "timezone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._username) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._displayName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._avatarURL) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._langTag) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timezone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._username {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._displayName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._avatarURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._langTag {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._timezone {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_UpdateAccountRequest, rhs: Nakama_Api_UpdateAccountRequest) -> Bool {
    if lhs._username != rhs._username {return false}
    if lhs._displayName != rhs._displayName {return false}
    if lhs._avatarURL != rhs._avatarURL {return false}
    if lhs._langTag != rhs._langTag {return false}
    if lhs._location != rhs._location {return false}
    if lhs._timezone != rhs._timezone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_UpdateGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "lang_tag"),
    5: .standard(proto: "avatar_url"),
    6: .same(proto: "open"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._langTag) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._avatarURL) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._open) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._langTag {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._avatarURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._open {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_UpdateGroupRequest, rhs: Nakama_Api_UpdateGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._name != rhs._name {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._langTag != rhs._langTag {return false}
    if lhs._avatarURL != rhs._avatarURL {return false}
    if lhs._open != rhs._open {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "username"),
    3: .standard(proto: "display_name"),
    4: .standard(proto: "avatar_url"),
    5: .standard(proto: "lang_tag"),
    6: .same(proto: "location"),
    7: .same(proto: "timezone"),
    8: .same(proto: "metadata"),
    9: .standard(proto: "facebook_id"),
    10: .standard(proto: "google_id"),
    11: .standard(proto: "gamecenter_id"),
    12: .standard(proto: "steam_id"),
    13: .same(proto: "online"),
    14: .standard(proto: "edge_count"),
    15: .standard(proto: "create_time"),
    16: .standard(proto: "update_time"),
    17: .standard(proto: "facebook_instant_game_id"),
    18: .standard(proto: "apple_id"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _username: String = String()
    var _displayName: String = String()
    var _avatarURL: String = String()
    var _langTag: String = String()
    var _location: String = String()
    var _timezone: String = String()
    var _metadata: String = String()
    var _facebookID: String = String()
    var _googleID: String = String()
    var _gamecenterID: String = String()
    var _steamID: String = String()
    var _online: Bool = false
    var _edgeCount: Int32 = 0
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _facebookInstantGameID: String = String()
    var _appleID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _username = source._username
      _displayName = source._displayName
      _avatarURL = source._avatarURL
      _langTag = source._langTag
      _location = source._location
      _timezone = source._timezone
      _metadata = source._metadata
      _facebookID = source._facebookID
      _googleID = source._googleID
      _gamecenterID = source._gamecenterID
      _steamID = source._steamID
      _online = source._online
      _edgeCount = source._edgeCount
      _createTime = source._createTime
      _updateTime = source._updateTime
      _facebookInstantGameID = source._facebookInstantGameID
      _appleID = source._appleID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._username) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._langTag) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._location) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._timezone) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._metadata) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._facebookID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._googleID) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._gamecenterID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._steamID) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._online) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._edgeCount) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._facebookInstantGameID) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._appleID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 2)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 3)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 4)
      }
      if !_storage._langTag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._langTag, fieldNumber: 5)
      }
      if !_storage._location.isEmpty {
        try visitor.visitSingularStringField(value: _storage._location, fieldNumber: 6)
      }
      if !_storage._timezone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._timezone, fieldNumber: 7)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadata, fieldNumber: 8)
      }
      if !_storage._facebookID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._facebookID, fieldNumber: 9)
      }
      if !_storage._googleID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._googleID, fieldNumber: 10)
      }
      if !_storage._gamecenterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gamecenterID, fieldNumber: 11)
      }
      if !_storage._steamID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._steamID, fieldNumber: 12)
      }
      if _storage._online != false {
        try visitor.visitSingularBoolField(value: _storage._online, fieldNumber: 13)
      }
      if _storage._edgeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._edgeCount, fieldNumber: 14)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._facebookInstantGameID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._facebookInstantGameID, fieldNumber: 17)
      }
      if !_storage._appleID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appleID, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_User, rhs: Nakama_Api_User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._langTag != rhs_storage._langTag {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._timezone != rhs_storage._timezone {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._facebookID != rhs_storage._facebookID {return false}
        if _storage._googleID != rhs_storage._googleID {return false}
        if _storage._gamecenterID != rhs_storage._gamecenterID {return false}
        if _storage._steamID != rhs_storage._steamID {return false}
        if _storage._online != rhs_storage._online {return false}
        if _storage._edgeCount != rhs_storage._edgeCount {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._facebookInstantGameID != rhs_storage._facebookInstantGameID {return false}
        if _storage._appleID != rhs_storage._appleID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_UserGroupList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGroupList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_groups"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userGroups) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userGroups, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_UserGroupList, rhs: Nakama_Api_UserGroupList) -> Bool {
    if lhs.userGroups != rhs.userGroups {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_UserGroupList.UserGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Nakama_Api_UserGroupList.protoMessageName + ".UserGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_UserGroupList.UserGroup, rhs: Nakama_Api_UserGroupList.UserGroup) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_UserGroupList.UserGroup.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUPERADMIN"),
    1: .same(proto: "ADMIN"),
    2: .same(proto: "MEMBER"),
    3: .same(proto: "JOIN_REQUEST"),
  ]
}

extension Nakama_Api_Users: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Users"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_Users, rhs: Nakama_Api_Users) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_WriteLeaderboardRecordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteLeaderboardRecordRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaderboard_id"),
    2: .same(proto: "record"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.leaderboardID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._record) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leaderboardID.isEmpty {
      try visitor.visitSingularStringField(value: self.leaderboardID, fieldNumber: 1)
    }
    if let v = self._record {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_WriteLeaderboardRecordRequest, rhs: Nakama_Api_WriteLeaderboardRecordRequest) -> Bool {
    if lhs.leaderboardID != rhs.leaderboardID {return false}
    if lhs._record != rhs._record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Nakama_Api_WriteLeaderboardRecordRequest.protoMessageName + ".LeaderboardRecordWrite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "subscore"),
    3: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.score) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.subscore) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.score != 0 {
      try visitor.visitSingularInt64Field(value: self.score, fieldNumber: 1)
    }
    if self.subscore != 0 {
      try visitor.visitSingularInt64Field(value: self.subscore, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite, rhs: Nakama_Api_WriteLeaderboardRecordRequest.LeaderboardRecordWrite) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs.subscore != rhs.subscore {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_WriteStorageObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteStorageObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
    4: .same(proto: "version"),
    5: .standard(proto: "permission_read"),
    6: .standard(proto: "permission_write"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collection) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._permissionRead) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._permissionWrite) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
    }
    if let v = self._permissionRead {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._permissionWrite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_WriteStorageObject, rhs: Nakama_Api_WriteStorageObject) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.version != rhs.version {return false}
    if lhs._permissionRead != rhs._permissionRead {return false}
    if lhs._permissionWrite != rhs._permissionWrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_WriteStorageObjectsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteStorageObjectsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "objects"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.objects) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_WriteStorageObjectsRequest, rhs: Nakama_Api_WriteStorageObjectsRequest) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_WriteTournamentRecordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteTournamentRecordRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tournament_id"),
    2: .same(proto: "record"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tournamentID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._record) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tournamentID.isEmpty {
      try visitor.visitSingularStringField(value: self.tournamentID, fieldNumber: 1)
    }
    if let v = self._record {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_WriteTournamentRecordRequest, rhs: Nakama_Api_WriteTournamentRecordRequest) -> Bool {
    if lhs.tournamentID != rhs.tournamentID {return false}
    if lhs._record != rhs._record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nakama_Api_WriteTournamentRecordRequest.TournamentRecordWrite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Nakama_Api_WriteTournamentRecordRequest.protoMessageName + ".TournamentRecordWrite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "subscore"),
    3: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.score) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.subscore) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.score != 0 {
      try visitor.visitSingularInt64Field(value: self.score, fieldNumber: 1)
    }
    if self.subscore != 0 {
      try visitor.visitSingularInt64Field(value: self.subscore, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Nakama_Api_WriteTournamentRecordRequest.TournamentRecordWrite, rhs: Nakama_Api_WriteTournamentRecordRequest.TournamentRecordWrite) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs.subscore != rhs.subscore {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
